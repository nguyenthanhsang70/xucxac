<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - Cờ vua</title>
    <!-- Load Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
      
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px;
            overflow-x: hidden;
        }
      
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 600px;
            margin-top: 10px;
        }
      
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 15px;
        }
      
        .back-btn {
            position: absolute;
            left: 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
      
        .back-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
        }
      
        h1 {
            text-align: center;
            color: #333;
            font-size: clamp(1.5rem, 4vw, 2rem);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            margin: 0;
        }
      
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 12px;
            background: linear-gradient(45deg, #f0f2f5, #e1e8ed);
            border-radius: 10px;
        }
        .turn-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
      
        .turn-indicator {
            font-size: clamp(1rem, 3vw, 1.2rem);
            font-weight: bold;
            color: #333;
            text-align: center;
            flex: 1;
            min-width: 150px;
        }
      
        .game-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
      
        .mode-select {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
            min-width: 120px;
        }
      
        .mode-select:hover {
            transform: translateY(-1px);
        }
      
        .thinking {
            color: #ff9800;
            font-style: italic;
        }
      
        .reset-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.4);
            min-width: 100px;
        }
      
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 90, 36, 0.6);
        }
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
      
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 3px solid #8b4513;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
        }
      
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 6vw, 2.2rem);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            aspect-ratio: 1;
        }
      
        .square.light {
            background: #f0d9b5;
        }
      
        .square.dark {
            background: #b58863;
        }
      
        .square.selected {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 0 3px #ff9800;
        }
      
        .square.possible-move {
            background: rgba(76, 175, 80, 0.6) !important;
        }
      
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            background: #4caf50;
            border-radius: 50%;
            opacity: 0.8;
        }
      
        .square.capture {
            background: rgba(244, 67, 54, 0.6) !important;
        }
      
        .square.capture::after {
            content: '';
            position: absolute;
            border: 2px solid #f44336;
            border-radius: 50%;
            width: 80%;
            height: 80%;
        }
      
        .square:hover {
            filter: brightness(1.1);
        }
      
        .piece {
            user-select: none;
            transition: all 0.2s ease;
            pointer-events: none;
        }
      
        .piece:hover {
            transform: scale(1.05);
        }
      
        .coordinates {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            margin-top: 5px;
            width: 100%;
            max-width: 400px;
        }
      
        .coord {
            text-align: center;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            color: #666;
            font-weight: bold;
            padding: 2px;
        }
      
        .status {
            text-align: center;
            margin-top: 15px;
            font-size: clamp(1rem, 3vw, 1.1rem);
            font-weight: bold;
            color: #333;
            min-height: 25px;
            padding: 0 10px;
        }
      
        .check {
            color: #f44336;
            animation: pulse 1s infinite;
        }
      
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        /* Tablet styles */
        @media (min-width: 768px) {
            body {
                padding: 20px;
                justify-content: center;
            }
           
            .game-container {
                padding: 25px;
                max-width: 650px;
                margin-top: 0;
            }
            .game-info {
                flex-direction: row;
                align-items: center;
            }
            .turn-info {
                flex-direction: row;
                justify-content: space-between;
            }
            .turn-indicator {
                text-align: left;
                flex: none;
            }
            .chessboard {
                max-width: 500px;
            }
            .coordinates {
                max-width: 500px;
            }
        }
        /* Desktop styles */
        @media (min-width: 1024px) {
            .game-container {
                padding: 30px;
                max-width: 700px;
            }
            .chessboard {
                max-width: 560px;
            }
            .coordinates {
                max-width: 560px;
            }
        }
      
        /* Small mobile phones */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .game-container {
                padding: 10px;
                border-radius: 10px;
            }
          
            .back-btn {
                padding: 6px 8px;
                font-size: 0.9rem;
            }
            .game-info {
                padding: 8px;
            }
            .mode-select, .reset-btn {
                padding: 6px 10px;
                font-size: 0.8rem;
                min-width: auto;
            }
            .game-controls {
                gap: 8px;
            }
        }
        /* Very small screens */
        @media (max-width: 350px) {
            .game-controls {
                flex-direction: column;
                width: 100%;
            }
            .mode-select, .reset-btn {
                width: 100%;
                max-width: 200px;
            }
            .turn-info {
                flex-direction: column;
                text-align: center;
            }
        }
        /* Landscape orientation on mobile */
        @media (max-height: 600px) and (orientation: landscape) {
            body {
                justify-content: flex-start;
                padding: 5px;
            }
            .game-container {
                margin-top: 5px;
            }
            h1 {
                font-size: 1.3rem;
            }
            .status {
                margin-top: 10px;
            }
        }
        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            .square {
                min-height: 44px; /* Minimum touch target size */
                min-width: 44px;
            }
           
            .back-btn, .mode-select, .reset-btn {
                min-height: 44px;
                min-width: 44px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <a href="game.html" class="back-btn"><i class="fas fa-arrow-left"></i></a>
            <h1>♔ Chess - Cờ vua ♛</h1>
        </div>
      
        <div class="game-info">
            <div class="turn-info">
                <div class="turn-indicator" id="turnIndicator">White's Turn</div>
                <div class="game-controls">
                    <select id="gameMode" onchange="changeGameMode()" class="mode-select">
                        <option value="human">2 Người chơi</option>
                        <option value="ai">Chơi với máy</option>
                    </select>
                    <button class="reset-btn" onclick="resetGame()">Ván mới</button>
                </div>
            </div>
        </div>
      
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
           
            <div class="coordinates">
                <div class="coord">a</div>
                <div class="coord">b</div>
                <div class="coord">c</div>
                <div class="coord">d</div>
                <div class="coord">e</div>
                <div class="coord">f</div>
                <div class="coord">g</div>
                <div class="coord">h</div>
            </div>
        </div>
      
        <div class="status" id="gameStatus"></div>
    </div>
    <script>
        const pieces = {
            white: {
                king: '♔', queen: '♕', rook: '♖',
                bishop: '♗', knight: '♘', pawn: '♙'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜',
                bishop: '♝', knight: '♞', pawn: '♟'
            }
        };
        let board = [
            ['♜','♞','♝','♛','♚','♝','♞','♜'],
            ['♟','♟','♟','♟','♟','♟','♟','♟'],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            ['♙','♙','♙','♙','♙','♙','♙','♙'],
            ['♖','♘','♗','♕','♔','♗','♘','♖']
        ];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameOver = false;
        let gameMode = 'human';
        let isAIThinking = false;
        let lastGameResult = null;
        let moveHistory = [];
        function initializeBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', handleSquareClick);
                  
                    if (board[row][col]) {
                        const piece = document.createElement('span');
                        piece.className = 'piece';
                        piece.textContent = board[row][col];
                        square.appendChild(piece);
                    }
                  
                    chessboard.appendChild(square);
                }
            }
        }
        function handleSquareClick(event) {
            if (gameOver || isAIThinking) return;
            if (gameMode === 'ai' && currentPlayer === 'black') return;
            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);
            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    clearHighlights();
                    switchPlayer();
                    updateDisplay();
                    if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    clearHighlights();
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        selectSquare(row, col);
                    } else {
                        selectedSquare = null;
                    }
                }
            } else {
                if (isPieceOwnedByCurrentPlayer(row, col)) {
                    selectSquare(row, col);
                }
            }
        }
        function selectSquare(row, col) {
            selectedSquare = { row, col };
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            highlightPossibleMoves(row, col);
        }
        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'capture');
            });
        }
        function highlightPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (board[r][c] && !isPieceOwnedByCurrentPlayer(r, c)) {
                            square.classList.add('capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }
        function isPieceOwnedByCurrentPlayer(row, col) {
            const piece = board[row][col];
            if (!piece) return false;
            const whitePieces = Object.values(pieces.white);
            const blackPieces = Object.values(pieces.black);
            return (currentPlayer === 'white' && whitePieces.includes(piece)) ||
                   (currentPlayer === 'black' && blackPieces.includes(piece));
        }
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            if (targetPiece && isPieceOwnedByCurrentPlayer(toRow, toCol)) return false;
            switch (piece) {
                case '♙': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'white');
                case '♟': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'black');
                case '♖': case '♜': return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case '♗': case '♝': return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♕': case '♛': return isValidRookMove(fromRow, fromCol, toRow, toCol) || isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♔': case '♚': return isValidKingMove(fromRow, fromCol, toRow, toCol);
                case '♘': case '♞': return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                default: return false;
            }
        }
        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const targetPiece = board[toRow][toCol];
            if (fromCol === toCol && toRow === fromRow + direction && !targetPiece) return true;
            if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) return true;
            if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && targetPiece) return true;
            return false;
        }
        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }
        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }
        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
        }
        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            return true;
        }
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const move = { fromRow, fromCol, toRow, toCol, piece: board[fromRow][fromCol], captured: board[toRow][toCol] };
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            moveHistory.push(move);
        }
        function undoMove() {
            const move = moveHistory.pop();
            if (!move) return;
            board[move.fromRow][move.fromCol] = move.piece;
            board[move.toRow][move.toCol] = move.captured;
        }
        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
        }
        function updateDisplay() {
            initializeBoard();
            const turnIndicator = document.getElementById('turnIndicator');
            if (isAIThinking) {
                turnIndicator.textContent = "Máy tính đang suy nghĩ...";
                turnIndicator.className = 'turn-indicator thinking';
            } else if (gameMode === 'ai') {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt của bạn" : "Lượt của máy";
                turnIndicator.className = 'turn-indicator';
            } else {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt quân Trắng" : "Lượt quân Đen";
                turnIndicator.className = 'turn-indicator';
            }
            const status = document.getElementById('gameStatus');
            const gameResult = isGameOver();
            if (gameResult) {
                let message;
                if (gameResult === 'checkmate') {
                    if (gameMode === 'ai') {
                        if (currentPlayer === 'white') {
                            message = 'Chiếu bí! Máy tính thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Máy tính thắng!');
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        } else {
                            message = 'Chiếu bí! Bạn thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Bạn thắng!');
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        }
                    } else {
                        const winner = currentPlayer === 'white' ? 'Đen' : 'Trắng';
                        message = `Chiếu bí! Quân ${winner} thắng!`;
                        if (lastGameResult !== message) {
                            alert(`Chiếu bí! Quân ${winner} thắng!`);
                            lastGameResult = message;
                        }
                        status.textContent = message;
                    }
                } else if (gameResult === 'stalemate' || gameResult === 'threefold') {
                    message = 'Hòa! Ván cờ kết thúc do bế tắc.';
                    if (lastGameResult !== message) {
                        alert('Hòa! Ván cờ kết thúc do bế tắc.');
                        lastGameResult = message;
                    }
                    status.textContent = message;
                }
                status.className = 'status check';
                gameOver = true;
            } else if (isCheck()) {
                status.textContent = 'Chiếu!';
                status.className = 'status check';
            } else {
                status.textContent = '';
                status.className = 'status';
            }
        }
        function isCheck() {
            const kingPiece = currentPlayer === 'white' ? '♔' : '♚';
            let kingPos = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        kingPos = { row, col };
                        break;
                    }
                }
            }
            if (!kingPos) return false;
            const opponent = currentPlayer === 'white' ? 'black' : 'white';
            const originalPlayer = currentPlayer;
            currentPlayer = opponent;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, kingPos.row, kingPos.col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }
        function isStalemate() {
            if (isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        function isThreefoldRepetition() {
            if (moveHistory.length < 8) return false;
            const currentBoard = JSON.stringify(board);
            let count = 1;
            for (let i = moveHistory.length - 2; i >= 0; i -= 2) {
                const pastBoard = JSON.stringify(moveHistory[i].boardAfter);
                if (pastBoard === currentBoard) count++;
                if (count >= 3) return true;
            }
            return false;
        }
        function isGameOver() {
            if (isCheck()) {
                if (isCheckmate()) return 'checkmate';
            } else {
                if (isStalemate()) return 'stalemate';
                if (isThreefoldRepetition()) return 'threefold';
            }
            return false;
        }
        function isCheckmate() {
            if (!isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        function resetGame() {
            board = [
                ['♜','♞','♝','♛','♚','♝','♞','♜'],
                ['♟','♟','♟','♟','♟','♟','♟','♟'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['♙','♙','♙','♙','♙','♙','♙','♙'],
                ['♖','♘','♗','♕','♔','♗','♘','♖']
            ];
            currentPlayer = 'white';
            selectedSquare = null;
            gameOver = false;
            isAIThinking = false;
            lastGameResult = null;
            moveHistory = [];
            clearHighlights();
            updateDisplay();
        }
        function changeGameMode() {
            gameMode = document.getElementById('gameMode').value;
            resetGame();
        }
        function makeAIMove() {
            if (gameOver || currentPlayer !== 'black') return;
            isAIThinking = true;
            updateDisplay();
            const bestMove = findBestMove();
            if (bestMove) {
                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                moveHistory[moveHistory.length - 1].boardAfter = JSON.parse(JSON.stringify(board));
                switchPlayer();
            }
            isAIThinking = false;
            updateDisplay();
        }
        function findBestMove() {
            let bestMove = null;
            let bestScore = -Infinity;
            const possibleMoves = getAllPossibleMoves('black');
            const orderedMoves = orderMoves(possibleMoves);
            const depth = isEndgame() ? 4 : 3;
            for (const move of orderedMoves) {
                const capturedPiece = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                board[move.fromRow][fromCol] = null;
                const score = minimax(depth, false, -Infinity, Infinity);
                board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = capturedPiece;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove || orderedMoves[0];
        }
        function minimax(depth, isMaximizing, alpha, beta) {
            if (depth === 0 || isGameOver()) {
                return evaluateBoard();
            }
            const player = isMaximizing ? 'black' : 'white';
            const moves = orderMoves(getAllPossibleMoves(player));
            if (moves.length === 0) {
                const originalPlayer = currentPlayer;
                currentPlayer = player;
                const inCheck = isCheck();
                currentPlayer = originalPlayer;
                return inCheck ? (isMaximizing ? -10000 : 10000) : 0;
            }
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    const eval = minimax(depth - 1, false, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    const eval = minimax(depth - 1, true, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        function orderMoves(moves) {
            const scoredMoves = moves.map(move => {
                let score = 0;
                const capturedPiece = board[move.toRow][move.toCol];
                if (capturedPiece) {
                    score += getPieceValue(capturedPiece);
                    if (capturedPiece === '♕' || capturedPiece === '♖') score += 50;
                }
                if (isCheckAfterMove(move)) score += 100;
                score += evaluateFork(move) * 50;
                score += evaluatePin(move) * 40;
                return { ...move, score };
            });
            return scoredMoves.sort((a, b) => b.score - a.score);
        }
        function getAllPossibleMoves(player) {
            const moves = [];
            const originalPlayer = currentPlayer;
            currentPlayer = player;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const capturedPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const inCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = capturedPiece;
                                    if (!inCheck) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return moves;
        }
        function evaluateBoard() {
            const pieceValues = {
                '♙': 10, '♟': -10, '♘': 30, '♞': -30, '♗': 30, '♝': -30,
                '♖': 50, '♜': -50, '♕': 90, '♛': -90, '♔': 900, '♚': -900
            };
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        score += pieceValues[piece] || 0;
                        if (piece === '♟' || piece === '♙') {
                            const advancement = piece === '♟' ? row : 7 - row;
                            score += (piece === '♟' ? -1 : 1) * advancement * 0.5;
                        }
                        if (row >= 3 && row <= 4 && col >= 3 && col <= 4) {
                            score += (piece === '♟' || piece === '♞' || piece === '♝' || piece === '♜' || piece === '♛') ? -1 : 1;
                        }
                    }
                }
            }
            return score;
        }
        function evaluateFork(move) {
            const piece = board[move.fromRow][move.fromCol];
            const attackedSquares = [];
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(move.toRow, move.toCol, row, col)) {
                        const targetPiece = board[row][col];
                        if (targetPiece && isPieceColor(targetPiece, 'white')) {
                            attackedSquares.push({row, col, piece: targetPiece});
                        }
                    }
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return attackedSquares.length >= 2 ? (attackedSquares.some(sq => sq.piece === '♔') ? 2 : 1) : 0;
        }
        function evaluatePin(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (!isLongRangePiece(piece)) return 0;
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            let pinScore = 0;
            const directions = getLongRangeDirections(piece);
            for (const [dRow, dCol] of directions) {
                let row = move.toRow + dRow;
                let col = move.toCol + dCol;
                let pinnedPiece = null;
                while (row >= 0 && row < 8 && col >= 0 && col < 8) {
                    const currentPiece = board[row][col];
                    if (currentPiece) {
                        if (!pinnedPiece && isPieceColor(currentPiece, 'white')) {
                            pinnedPiece = {row, col, piece: currentPiece};
                        } else if (pinnedPiece && currentPiece === '♔') {
                            pinScore += 1;
                            break;
                        } else {
                            break;
                        }
                    }
                    row += dRow;
                    col += dCol;
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return pinScore;
        }
        function isEndgame() {
            let pieceCount = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && !['♔', '♚'].includes(board[row][col])) {
                        pieceCount++;
                    }
                }
            }
            return pieceCount <= 12;
        }
        function isCheckAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            const originalPlayer = currentPlayer;
            currentPlayer = 'white';
            const inCheck = isCheck();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return inCheck;
        }
        function isPieceColor(piece, color) {
            const whitePieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
            const blackPieces = ['♚', '♛', '♜', '♝', '♞', '♟'];
            return color === 'white' ? whitePieces.includes(piece) : blackPieces.includes(piece);
        }
        function isLongRangePiece(piece) {
            return ['♕', '♛', '♖', '♜', '♗', '♝'].includes(piece);
        }
        function getLongRangeDirections(piece) {
            const rookDirections = [[0,1], [0,-1], [1,0], [-1,0]];
            const bishopDirections = [[1,1], [1,-1], [-1,1], [-1,-1]];
            if (['♖', '♜'].includes(piece)) return rookDirections;
            if (['♗', '♝'].includes(piece)) return bishopDirections;
            if (['♕', '♛'].includes(piece)) return [...rookDirections, ...bishopDirections];
            return [];
        }
        function getPieceValue(piece) {
            const values = {
                '♙': 10, '♟': 10, '♘': 30, '♞': 30, '♗': 30, '♝': 30,
                '♖': 50, '♜': 50, '♕': 90, '♛': 90, '♔': 900, '♚': 900
            };
            return values[piece] || 0;
        }
        initializeBoard();
        updateDisplay();
    </script>
</body>
</html>
