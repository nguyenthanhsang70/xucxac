<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cờ vua - NTS</title>
    <link rel="icon" type="image/png" href="logos3.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
      
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
      
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 500px;
        }
      
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 15px;
        }
      
        .back-btn {
            position: absolute;
            left: 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
      
        .back-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
      
        h1 {
            text-align: center;
            color: #333;
            font-size: 1.8rem;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            padding: 0 40px;
        }
      
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(45deg, #f0f2f5, #e1e8ed);
            border-radius: 8px;
        }
      
        .turn-indicator {
            font-size: 1rem;
            font-weight: bold;
            color: #333;
            text-align: center;
        }
      
        .game-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
      
        .mode-select {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
        }
      
        .mode-select:hover {
            transform: translateY(-1px);
        }
      
        .thinking {
            color: #ff9800;
            font-style: italic;
        }
      
        .reset-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(238, 90, 36, 0.3);
        }
      
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(238, 90, 36, 0.4);
        }
      
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 3px solid #8b4513;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
      
        .square {
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            cursor: pointer;
            position: relative;
            min-width: 30px;
        }
      
        .square.light {
            background: #f0d9b5;
        }
      
        .square.dark {
            background: #b58863;
        }
      
        .square.selected {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 0 2px #ff9800;
        }
      
        .square.possible-move {
            background: rgba(76, 175, 80, 0.6) !important;
        }
      
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: #4caf50;
            border-radius: 50%;
            opacity: 0.8;
        }
      
        .square.capture {
            background: rgba(244, 67, 54, 0.6) !important;
        }
      
        .square.capture::after {
            content: '';
            position: absolute;
            border: 2px solid #f44336;
            border-radius: 50%;
            width: 85%;
            height: 85%;
        }
      
        .square:hover {
            filter: brightness(1.1);
        }
      
        .piece {
            user-select: none;
            transition: all 0.2s ease;
        }
      
        .piece:hover {
            transform: scale(1.1);
        }
      
        .status {
            text-align: center;
            margin-top: 15px;
            font-size: 1rem;
            font-weight: bold;
            color: #333;
            min-height: 20px;
        }
      
        .check {
            color: #f44336;
            animation: pulse 1s infinite;
        }
      
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
      
        .coordinates {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            margin-top: 5px;
        }
      
        .coord {
            text-align: center;
            font-size: 0.7rem;
            color: #666;
            font-weight: bold;
        }
      
        @media (max-width: 500px) {
            .game-container {
                padding: 10px;
                border-radius: 12px;
            }
            
            h1 {
                font-size: 1.5rem;
                padding: 0 35px;
            }
            
            .square {
                font-size: clamp(1.2rem, 5vw, 1.8rem);
            }
            
            .coord {
                font-size: 0.6rem;
            }
            
            .game-info {
                padding: 8px;
            }
            
            .turn-indicator,
            .mode-select,
            .reset-btn {
                font-size: 0.85rem;
            }
        }
      
        @media (max-width: 400px) {
            h1 {
                font-size: 1.3rem;
            }
            
            .square {
                font-size: clamp(1rem, 6vw, 1.5rem);
            }
            
            .back-btn {
                padding: 5px 8px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <a href="game.html" class="back-btn" id="backButton"><i class="fas fa-arrow-left"></i></a>
            <h1>♔ Cờ vua ♛</h1>
        </div>
      
        <div class="game-info">
            <div class="turn-indicator" id="turnIndicator">Black's Turn</div>
            <div class="game-controls">
                <select id="gameMode" onchange="changeGameMode()" class="mode-select">
                    <option value="human">2 Người chơi</option>
                    <option value="ai" selected>Chơi với máy</option>
                </select>
                <button class="reset-btn" onclick="resetGame()">Ván mới</button>
            </div>
        </div>
      
        <div class="chessboard" id="chessboard"></div>
      
        <div class="coordinates">
            <div class="coord">a</div>
            <div class="coord">b</div>
            <div class="coord">c</div>
            <div class="coord">d</div>
            <div class="coord">e</div>
            <div class="coord">f</div>
            <div class="coord">g</div>
            <div class="coord">h</div>
        </div>
      
        <div class="status" id="gameStatus"></div>
    </div>
    <audio id="winSound" src="win.mp3"></audio>
    <audio id="loseSound" src="lose.mp3"></audio>
    <audio id="tieSound" src="tie.mp3"></audio>
    <script>
        const pieces = {
            white: {
                king: '♔', queen: '♕', rook: '♖',
                bishop: '♗', knight: '♘', pawn: '♙'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜',
                bishop: '♝', knight: '♞', pawn: '♟'
            }
        };
        const pieceValues = {
            '♙': 100, '♟': -100, '♘': 320, '♞': -320, '♗': 330, '♝': -330,
            '♖': 500, '♜': -500, '♕': 900, '♛': -900, '♔': 20000, '♚': -20000
        };
        const pawnTable = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5, 5, 10, 25, 25, 10, 5, 5],
            [0, 0, 0, 20, 20, 0, 0, 0],
            [5, -5,-10, 0, 0,-10, -5, 5],
            [5, 10, 10,-20,-20, 10, 10, 5],
            [0, 0, 0, 0, 0, 0, 0, 0]
        ];
        const knightTable = [
            [-50,-40,-30,-30,-30,-30,-40,-50],
            [-40,-20, 0, 0, 0, 0,-20,-40],
            [-30, 0, 10, 15, 15, 10, 0,-30],
            [-30, 5, 15, 20, 20, 15, 5,-30],
            [-30, 0, 15, 20, 20, 15, 0,-30],
            [-30, 5, 10, 15, 15, 10, 5,-30],
            [-40,-20, 0, 5, 5, 0,-20,-40],
            [-50,-40,-30,-30,-30,-30,-40,-50]
        ];
        const bishopTable = [
            [-20,-10,-10,-10,-10,-10,-10,-20],
            [-10, 0, 0, 0, 0, 0, 0,-10],
            [-10, 0, 5, 10, 10, 5, 0,-10],
            [-10, 5, 5, 10, 10, 5, 5,-10],
            [-10, 0, 10, 10, 10, 10, 0,-10],
            [-10, 10, 10, 10, 10, 10, 10,-10],
            [-10, 5, 0, 0, 0, 0, 5,-10],
            [-20,-10,-10,-10,-10,-10,-10,-20]
        ];
        const rookTable = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [5, 10, 10, 10, 10, 10, 10, 5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [0, 0, 0, 5, 5, 0, 0, 0]
        ];
        const queenTable = [
            [-20,-10,-10, -5, -5,-10,-10,-20],
            [-10, 0, 0, 0, 0, 0, 0,-10],
            [-10, 0, 5, 5, 5, 5, 0,-10],
            [-5, 0, 5, 5, 5, 5, 0, -5],
            [0, 0, 5, 5, 5, 5, 0, -5],
            [-10, 5, 5, 5, 5, 5, 0,-10],
            [-10, 0, 5, 0, 0, 0, 0,-10],
            [-20,-10,-10, -5, -5,-10,-10,-20]
        ];
        const kingTableMid = [
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-20,-30,-30,-40,-40,-30,-30,-20],
            [-10,-20,-20,-20,-20,-20,-20,-10],
            [20, 20, 0, 0, 0, 0, 20, 20],
            [20, 30, 10, 0, 0, 10, 30, 20]
        ];
        const kingTableEnd = [
            [-50,-40,-30,-20,-20,-30,-40,-50],
            [-30,-20,-10, 0, 0,-10,-20,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-30, 0, 0, 0, 0,-30,-30],
            [-50,-30,-30,-30,-30,-30,-30,-50]
        ];
        let board = [
            ['♜','♞','♝','♛','♚','♝','♞','♜'],
            ['♟','♟','♟','♟','♟','♟','♟','♟'],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            ['♙','♙','♙','♙','♙','♙','♙','♙'],
            ['♖','♘','♗','♕','♔','♗','♘','♖']
        ];
        let currentPlayer = 'black';
        let selectedSquare = null;
        let gameOver = false;
        let gameMode = 'ai';
        let isAIThinking = false;
        let lastGameResult = null;
        let moveHistory = [];
        const transpositionTable = new Map();
        const MAX_TABLE_SIZE = 1000000;

        // Xử lý nút Quay lại
        const backButton = document.getElementById('backButton');
        if (backButton) {
            backButton.addEventListener('click', function(event) {
                console.log('Back button clicked, redirecting to game.html');
                window.location.href = 'game.html';
            });
        } else {
            console.error('Back button element not found');
        }

        function initializeBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', handleSquareClick);
                  
                    if (board[row][col]) {
                        const piece = document.createElement('span');
                        piece.className = 'piece';
                        piece.textContent = board[row][col];
                        square.appendChild(piece);
                    }
                  
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(event) {
            if (gameOver || isAIThinking) return;
            if (gameMode === 'ai' && currentPlayer === 'black') return;
            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);
            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    clearHighlights();
                    switchPlayer();
                    updateDisplay();
                    if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    clearHighlights();
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        selectSquare(row, col);
                    } else {
                        selectedSquare = null;
                    }
                }
            } else {
                if (isPieceOwnedByCurrentPlayer(row, col)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            selectedSquare = { row, col };
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            highlightPossibleMoves(row, col);
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'capture');
            });
        }

        function highlightPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (board[r][c] && !isPieceOwnedByCurrentPlayer(r, c)) {
                            square.classList.add('capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }

        function isPieceOwnedByCurrentPlayer(row, col) {
            const piece = board[row][col];
            if (!piece) return false;
            const whitePieces = Object.values(pieces.white);
            const blackPieces = Object.values(pieces.black);
            return (currentPlayer === 'white' && whitePieces.includes(piece)) ||
                   (currentPlayer === 'black' && blackPieces.includes(piece));
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            if (targetPiece && isPieceOwnedByCurrentPlayer(toRow, toCol)) return false;
            switch (piece) {
                case '♙': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'white');
                case '♟': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'black');
                case '♖': case '♜': return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case '♗': case '♝': return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♕': case '♛': return isValidRookMove(fromRow, fromCol, toRow, toCol) || isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♔': case '♚': return isValidKingMove(fromRow, fromCol, toRow, toCol);
                case '♘': case '♞': return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                default: return false;
            }
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const targetPiece = board[toRow][toCol];
            if (fromCol === toCol && toRow === fromRow + direction && !targetPiece) return true;
            if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) return true;
            if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && targetPiece) return true;
            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            return true;
        }

        // Hàm kiểm tra số lượng quân hậu
        function countQueens(color) {
            const queen = color === 'white' ? '♕' : '♛';
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === queen) count++;
                }
            }
            return count;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const move = { fromRow, fromCol, toRow, toCol, piece: board[fromRow][fromCol], captured: board[toRow][toCol] };
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            // Chỉ phong hậu nếu chưa có quân hậu
            if (board[toRow][toCol] === '♟' && toRow === 7 && countQueens('black') === 0) {
                board[toRow][toCol] = '♛';
                move.promotedTo = '♛';
            } else if (board[toRow][toCol] === '♙' && toRow === 0 && countQueens('white') === 0) {
                board[toRow][toCol] = '♕';
                move.promotedTo = '♕';
            }
            moveHistory.push(move);
        }

        function undoMove() {
            const move = moveHistory.pop();
            if (!move) return;
            board[move.fromRow][move.fromCol] = move.piece;
            board[move.toRow][move.toCol] = move.captured;
            if (move.promotedTo) {
                board[move.fromRow][move.fromCol] = move.piece === '♟' ? '♟' : '♙';
            }
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
        }

        function updateDisplay() {
            initializeBoard();
            const turnIndicator = document.getElementById('turnIndicator');
            if (isAIThinking) {
                turnIndicator.textContent = "Máy tính đang suy nghĩ...";
                turnIndicator.className = 'turn-indicator thinking';
            } else if (gameMode === 'ai') {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt của bạn" : "Lượt của máy";
                turnIndicator.className = 'turn-indicator';
            } else {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt quân Trắng" : "Lượt quân Đen";
                turnIndicator.className = 'turn-indicator';
            }
            const status = document.getElementById('gameStatus');
            const gameResult = isGameOver();
            const winSound = document.getElementById('winSound');
            const loseSound = document.getElementById('loseSound');
            const tieSound = document.getElementById('tieSound');
            if (gameResult) {
                let message;
                if (gameResult === 'checkmate') {
                    if (gameMode === 'ai') {
                        if (currentPlayer === 'white') {
                            message = 'Chiếu bí! Máy tính thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Máy tính thắng!');
                                winSound.play().catch(e => console.error("Error playing win sound:", e));
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        } else {
                            message = 'Chiếu bí! Bạn thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Bạn thắng!');
                                loseSound.play().catch(e => console.error("Error playing lose sound:", e));
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        }
                    } else {
                        const winner = currentPlayer === 'white' ? 'Đen' : 'Trắng';
                        message = `Chiếu bí! Quân ${winner} thắng!`;
                        if (lastGameResult !== message) {
                            alert(`Chiếu bí! Quân ${winner} thắng!`);
                            if (winner === 'Đen') {
                                winSound.play().catch(e => console.error("Error playing win sound:", e));
                            } else {
                                loseSound.play().catch(e => console.error("Error playing lose sound:", e));
                            }
                            lastGameResult = message;
                        }
                        status.textContent = message;
                    }
                } else if (gameResult === 'stalemate' || gameResult === 'threefold') {
                    message = 'Hòa! Ván cờ kết thúc do bế tắc.';
                    if (lastGameResult !== message) {
                        alert('Hòa! Ván cờ kết thúc do bế tắc.');
                        tieSound.play().catch(e => console.error("Error playing tie sound:", e));
                        lastGameResult = message;
                    }
                    status.textContent = message;
                }
                status.className = 'status check';
                gameOver = true;
            } else if (isCheck()) {
                status.textContent = 'Chiếu!';
                status.className = 'status check';
            } else {
                status.textContent = '';
                status.className = 'status';
            }
        }

        function isCheck() {
            const kingPiece = currentPlayer === 'white' ? '♔' : '♚';
            let kingPos = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        kingPos = { row, col };
                        break;
                    }
                }
            }
            if (!kingPos) return false;
            const opponent = currentPlayer === 'white' ? 'black' : 'white';
            const originalPlayer = currentPlayer;
            currentPlayer = opponent;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, kingPos.row, kingPos.col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }

        function isStalemate() {
            if (isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        function isThreefoldRepetition() {
            if (moveHistory.length < 8) return false;
            const currentBoard = JSON.stringify(board);
            let count = 1;
            for (let i = moveHistory.length - 2; i >= 0; i -= 2) {
                const pastBoard = JSON.stringify(moveHistory[i].boardAfter);
                if (pastBoard === currentBoard) count++;
                if (count >= 3) return true;
            }
            return false;
        }

        function isGameOver() {
            if (isCheck()) {
                if (isCheckmate()) return 'checkmate';
            } else {
                if (isStalemate()) return 'stalemate';
                if (isThreefoldRepetition()) return 'threefold';
            }
            return false;
        }

        function isCheckmate() {
            if (!isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        function resetGame() {
            board = [
                ['♜','♞','♝','♛','♚','♝','♞','♜'],
                ['♟','♟','♟','♟','♟','♟','♟','♟'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['♙','♙','♙','♙','♙','♙','♙','♙'],
                ['♖','♘','♗','♕','♔','♗','♘','♖']
            ];
            currentPlayer = 'black';
            selectedSquare = null;
            gameOver = false;
            isAIThinking = false;
            lastGameResult = null;
            moveHistory = [];
            transpositionTable.clear();
            clearHighlights();
            updateDisplay();
            if (gameMode === 'ai') {
                setTimeout(makeAIMove, 500);
            }
        }

        function changeGameMode() {
            gameMode = document.getElementById('gameMode').value;
            resetGame();
        }

        function isEndgame() {
            let pieceCount = 0;
            let queenCount = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col]) {
                        if (['♕', '♛'].includes(board[row][col])) queenCount++;
                        if (!['♔', '♚'].includes(board[row][col])) pieceCount++;
                    }
                }
            }
            return pieceCount <= 10 || queenCount === 0;
        }

        function orderMoves(moves) {
            const scoredMoves = moves.map(move => {
                let score = 0;
                const capturedPiece = board[move.toRow][move.toCol];
                const movingPiece = board[move.fromRow][move.fromCol];
                if (capturedPiece) {
                    score += getPieceValue(capturedPiece) - getPieceValue(movingPiece) * 0.1;
                }
                if (isCheckAfterMove(move)) score += 10000;
                if (isCheckmateAfterMove(move)) score += 1000000;
                if (isPromotionMove(move)) score += 9000;
                return { ...move, score };
            });
            return scoredMoves.sort((a, b) => b.score - a.score);
        }

        function evaluateBoard() {
            let score = 0;
            let mobilityScore = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        score += pieceValues[piece] || 0;
                        const isWhite = isPieceColor(piece, 'white');
                        const tableRow = isWhite ? row : 7 - row;
                        switch (piece) {
                            case '♙': score += pawnTable[tableRow][col]; break;
                            case '♟': score -= pawnTable[tableRow][col]; break;
                            case '♘': score += knightTable[tableRow][col]; break;
                            case '♞': score -= knightTable[tableRow][col]; break;
                            case '♗': score += bishopTable[tableRow][col]; break;
                            case '♝': score -= bishopTable[tableRow][col]; break;
                            case '♖': score += rookTable[tableRow][col]; break;
                            case '♜': score -= rookTable[tableRow][col]; break;
                            case '♕': score += queenTable[tableRow][col]; break;
                            case '♛': score -= queenTable[tableRow][col]; break;
                            case '♔': score += isEndgame() ? kingTableEnd[tableRow][col] : kingTableMid[tableRow][col]; break;
                            case '♚': score -= isEndgame() ? kingTableEnd[tableRow][col] : kingTableMid[tableRow][col]; break;
                        }
                    }
                }
            }
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            mobilityScore -= getAllPossibleMoves('black').length * 5;
            currentPlayer = 'white';
            mobilityScore += getAllPossibleMoves('white').length * 5;
            currentPlayer = originalPlayer;
            return score + mobilityScore;
        }

        function findBestMove() {
            let bestMove = null;
            let bestScore = -Infinity;
            const possibleMoves = getAllPossibleMoves('black');
            const orderedMoves = orderMoves(possibleMoves);
            const maxDepth = isEndgame() ? 6 : 4;
            const startTime = performance.now();
            const timeLimit = 1000;
            for (let depth = 1; depth <= maxDepth; depth++) {
                let currentBestScore = -Infinity;
                let currentBestMove = null;
                for (const move of orderedMoves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    if (board[move.toRow][move.toCol] === '♟' && move.toRow === 7 && countQueens('black') === 0) {
                        board[move.toRow][move.toCol] = '♛';
                    }
                    const score = minimax(depth - 1, false, -Infinity, Infinity);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    if (score > currentBestScore) {
                        currentBestScore = score;
                        currentBestMove = move;
                    }
                    if (performance.now() - startTime > timeLimit) {
                        break;
                    }
                }
                if (currentBestScore > bestScore) {
                    bestScore = currentBestScore;
                    bestMove = currentBestMove;
                }
                if (performance.now() - startTime > timeLimit) {
                    break;
                }
            }
            return bestMove || orderedMoves[0];
        }

        function minimax(depth, isMaximizing, alpha, beta) {
            const boardHash = getBoardHash();
            const stored = transpositionTable.get(boardHash);
            if (stored && stored.depth >= depth) {
                return stored.score;
            }
            if (depth === 0 || isGameOver()) {
                const score = evaluateBoard();
                if (transpositionTable.size < MAX_TABLE_SIZE) {
                    transpositionTable.set(boardHash, { score, depth });
                }
                return score;
            }
            const player = isMaximizing ? 'black' : 'white';
            const moves = orderMoves(getAllPossibleMoves(player));
            if (moves.length === 0) {
                const originalPlayer = currentPlayer;
                currentPlayer = player;
                const inCheck = isCheck();
                currentPlayer = originalPlayer;
                const score = inCheck ? (isMaximizing ? -100000 : 100000) : 0;
                if (transpositionTable.size < MAX_TABLE_SIZE) {
                    transpositionTable.set(boardHash, { score, depth });
                }
                return score;
            }
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    if (board[move.toRow][move.toCol] === '♟' && move.toRow === 7 && countQueens('black') === 0) {
                        board[move.toRow][move.toCol] = '♛';
                    }
                    const eval = minimax(depth - 1, false, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                if (transpositionTable.size < MAX_TABLE_SIZE) {
                    transpositionTable.set(boardHash, { score: maxEval, depth });
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    if (board[move.toRow][move.toCol] === '♙' && move.toRow === 0 && countQueens('white') === 0) {
                        board[move.toRow][move.toCol] = '♕';
                    }
                    const eval = minimax(depth - 1, true, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                if (transpositionTable.size < MAX_TABLE_SIZE) {
                    transpositionTable.set(boardHash, { score: minEval, depth });
                }
                return minEval;
            }
        }

        function getBoardHash() {
            return JSON.stringify(board) + currentPlayer;
        }

        function makeAIMove() {
            if (gameOver || currentPlayer !== 'black') return;
            isAIThinking = true;
            updateDisplay();
            const startTime = performance.now();
            const bestMove = findBestMove();
            console.log(`AI move calculated in ${performance.now() - startTime}ms`);
            if (bestMove) {
                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                moveHistory[moveHistory.length - 1].boardAfter = JSON.parse(JSON.stringify(board));
                switchPlayer();
            }
            isAIThinking = false;
            updateDisplay();
        }

        function isCheckAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            if (board[move.toRow][move.toCol] === '♟' && move.toRow === 7 && countQueens('black') === 0) {
                board[move.toRow][move.toCol] = '♛';
            }
            const originalPlayer = currentPlayer;
            currentPlayer = 'white';
            const inCheck = isCheck();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return inCheck;
        }

        function isCheckmateAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            if (board[move.toRow][move.toCol] === '♟' && move.toRow === 7 && countQueens('black') === 0) {
                board[move.toRow][move.toCol] = '♛';
            }
            const originalPlayer = currentPlayer;
            currentPlayer = 'white';
            const isCheckmateResult = isCheckmate();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return isCheckmateResult;
        }

        function isPromotionMove(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (piece === '♟' && move.toRow === 7 && countQueens('black') === 0) return true;
            if (piece === '♙' && move.toRow === 0 && countQueens('white') === 0) return true;
            return false;
        }

        function isPieceColor(piece, color) {
            const whitePieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
            const blackPieces = ['♚', '♛', '♜', '♝', '♞', '♟'];
            return color === 'white' ? whitePieces.includes(piece) : blackPieces.includes(piece);
        }

        function getPieceValue(piece) {
            const values = {
                '♙': 100, '♟': 100, '♘': 320, '♞': 320, '♗': 330, '♝': 330,
                '♖': 500, '♜': 500, '♕': 900, '♛': 900, '♔': 20000, '♚': 20000
            };
            return values[piece] || 0;
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            const originalPlayer = currentPlayer;
            currentPlayer = player;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const capturedPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    let promoted = false;
                                    if (board[toRow][toCol] === '♟' && toRow === 7 && countQueens('black') === 0) {
                                        board[toRow][toCol] = '♛';
                                        promoted = true;
                                    } else if (board[toRow][toCol] === '♙' && toRow === 0 && countQueens('white') === 0) {
                                        board[toRow][toCol] = '♕';
                                        promoted = true;
                                    }
                                    const inCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = capturedPiece;
                                    if (promoted) {
                                        board[fromRow][fromCol] = board[fromRow][fromCol] === '♛' ? '♟' : '♙';
                                    }
                                    if (!inCheck) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return moves;
        }

        initializeBoard();
        updateDisplay();
        if (gameMode === 'ai') {
            setTimeout(makeAIMove, 500);
        }
    </script>
</body>
</html>
