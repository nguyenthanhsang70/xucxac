<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cờ vua - NTS</title>
    <link rel="icon" type="image/png" href="logos3.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
      
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
      
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 500px;
        }
      
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 15px;
        }
      
        .back-btn {
            position: absolute;
            left: 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
      
        .back-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
      
        h1 {
            text-align: center;
            color: #333;
            font-size: 1.8rem;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            padding: 0 40px;
        }
      
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(45deg, #f0f2f5, #e1e8ed);
            border-radius: 8px;
        }
      
        .turn-indicator {
            font-size: 1rem;
            font-weight: bold;
            color: #333;
            text-align: center;
        }
      
        .game-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
      
        .mode-select {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
        }
      
        .mode-select:hover {
            transform: translateY(-1px);
        }
      
        .thinking {
            color: #ff9800;
            font-style: italic;
        }
      
        .reset-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(238, 90, 36, 0.3);
        }
      
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(238, 90, 36, 0.4);
        }
      
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 3px solid #8b4513;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
      
        .square {
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            cursor: pointer;
            position: relative;
            min-width: 30px;
        }
      
        .square.light {
            background: #f0d9b5;
        }
      
        .square.dark {
            background: #b58863;
        }
      
        .square.selected {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 0 2px #ff9800;
        }
      
        .square.possible-move {
            background: rgba(76, 175, 80, 0.6) !important;
        }
      
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: #4caf50;
            border-radius: 50%;
            opacity: 0.8;
        }
      
        .square.capture {
            background: rgba(244, 67, 54, 0.6) !important;
        }
      
        .square.capture::after {
            content: '';
            position: absolute;
            border: 2px solid #f44336;
            border-radius: 50%;
            width: 85%;
            height: 85%;
        }
      
        .square:hover {
            filter: brightness(1.1);
        }
      
        .piece {
            user-select: none;
            transition: all 0.2s ease;
        }
      
        .piece:hover {
            transform: scale(1.1);
        }
      
        .status {
            text-align: center;
            margin-top: 15px;
            font-size: 1rem;
            font-weight: bold;
            color: #333;
            min-height: 20px;
        }
      
        .check {
            color: #f44336;
            animation: pulse 1s infinite;
        }
      
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
      
        .coordinates {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            margin-top: 5px;
        }
      
        .coord {
            text-align: center;
            font-size: 0.7rem;
            color: #666;
            font-weight: bold;
        }
      
        @media (max-width: 500px) {
            .game-container {
                padding: 10px;
                border-radius: 12px;
            }
            
            h1 {
                font-size: 1.5rem;
                padding: 0 35px;
            }
            
            .square {
                font-size: clamp(1.2rem, 5vw, 1.8rem);
            }
            
            .coord {
                font-size: 0.6rem;
            }
            
            .game-info {
                padding: 8px;
            }
            
            .turn-indicator,
            .mode-select,
            .reset-btn {
                font-size: 0.85rem;
            }
        }
      
        @media (max-width: 400px) {
            h1 {
                font-size: 1.3rem;
            }
            
            .square {
                font-size: clamp(1rem, 6vw, 1.5rem);
            }
            
            .back-btn {
                padding: 5px 8px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <a href="game.html" class="back-btn" id="backButton"><i class="fas fa-arrow-left"></i></a>
            <h1>♔ Cờ vua ♛</h1>
        </div>
      
        <div class="game-info">
            <div class="turn-indicator" id="turnIndicator">Black's Turn</div>
            <div class="game-controls">
                <select id="gameMode" onchange="changeGameMode()" class="mode-select">
                    <option value="human">2 Người chơi</option>
                    <option value="ai" selected>Chơi với máy</option>
                </select>
                <button class="reset-btn" onclick="resetGame()">Ván mới</button>
            </div>
        </div>
      
        <div class="chessboard" id="chessboard"></div>
      
        <div class="coordinates">
            <div class="coord">a</div>
            <div class="coord">b</div>
            <div class="coord">c</div>
            <div class="coord">d</div>
            <div class="coord">e</div>
            <div class="coord">f</div>
            <div class="coord">g</div>
            <div class="coord">h</div>
        </div>
      
        <div class="status" id="gameStatus"></div>
    </div>
    <audio id="winSound" src="win.mp3"></audio>
    <audio id="loseSound" src="lose.mp3"></audio>
    <audio id="tieSound" src="tie.mp3"></audio>
    <script>
        const pieces = {
            white: {
                king: '♔', queen: '♕', rook: '♖',
                bishop: '♗', knight: '♘', pawn: '♙'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜',
                bishop: '♝', knight: '♞', pawn: '♟'
            }
        };
        const pawnTable = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5, 5, 10, 25, 25, 10, 5, 5],
            [0, 0, 0, 20, 20, 0, 0, 0],
            [5, -5,-10, 0, 0,-10, -5, 5],
            [5, 10, 10,-20,-20, 10, 10, 5],
            [0, 0, 0, 0, 0, 0, 0, 0]
        ];
        const knightTable = [
            [-50,-40,-30,-30,-30,-30,-40,-50],
            [-40,-20, 0, 0, 0, 0,-20,-40],
            [-30, 0, 10, 15, 15, 10, 0,-30],
            [-30, 5, 15, 20, 20, 15, 5,-30],
            [-30, 0, 15, 20, 20, 15, 0,-30],
            [-30, 5, 10, 15, 15, 10, 5,-30],
            [-40,-20, 0, 5, 5, 0,-20,-40],
            [-50,-40,-30,-30,-30,-30,-40,-50]
        ];
        const bishopTable = [
            [-20,-10,-10,-10,-10,-10,-10,-20],
            [-10, 0, 0, 0, 0, 0, 0,-10],
            [-10, 0, 5, 10, 10, 5, 0,-10],
            [-10, 5, 5, 10, 10, 5, 5,-10],
            [-10, 0, 10, 10, 10, 10, 0,-10],
            [-10, 10, 10, 10, 10, 10, 10,-10],
            [-10, 5, 0, 0, 0, 0, 5,-10],
            [-20,-10,-10,-10,-10,-10,-10,-20]
        ];
        const rookTable = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [5, 10, 10, 10, 10, 10, 10, 5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [-5, 0, 0, 0, 0, 0, 0, -5],
            [0, 0, 0, 5, 5, 0, 0, 0]
        ];
        const queenTable = [
            [-20,-10,-10, -5, -5,-10,-10,-20],
            [-10, 0, 0, 0, 0, 0, 0,-10],
            [-10, 0, 5, 5, 5, 5, 0,-10],
            [-5, 0, 5, 5, 5, 5, 0, -5],
            [0, 0, 5, 5, 5, 5, 0, -5],
            [-10, 5, 5, 5, 5, 5, 0,-10],
            [-10, 0, 5, 0, 0, 0, 0,-10],
            [-20,-10,-10, -5, -5,-10,-10,-20]
        ];
        const kingTableMid = [
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-20,-30,-30,-40,-40,-30,-30,-20],
            [-10,-20,-20,-20,-20,-20,-20,-10],
            [20, 20, 0, 0, 0, 0, 20, 20],
            [20, 30, 10, 0, 0, 10, 30, 20]
        ];
        const kingTableEnd = [
            [-50,-40,-30,-20,-20,-30,-40,-50],
            [-30,-20,-10, 0, 0,-10,-20,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-30, 0, 0, 0, 0,-30,-30],
            [-50,-30,-30,-30,-30,-30,-30,-50]
        ];
        let board = [
            ['♜','♞','♝','♛','♚','♝','♞','♜'],
            ['♟','♟','♟','♟','♟','♟','♟','♟'],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            ['♙','♙','♙','♙','♙','♙','♙','♙'],
            ['♖','♘','♗','♕','♔','♗','♘','♖']
        ];
        let currentPlayer = 'black';
        let selectedSquare = null;
        let gameOver = false;
        let gameMode = 'ai';
        let isAIThinking = false;
        let lastGameResult = null;
        let moveHistory = [];
        const transpositionTable = new Map();

        // Thêm sự kiện cho nút quay lại
        document.getElementById('backButton').addEventListener('click', function(event) {
            event.preventDefault(); // Ngăn hành vi mặc định của thẻ <a>
            window.location.href = 'game.html'; // Chuyển hướng đến game.html
        });

        function initializeBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', handleSquareClick);
                  
                    if (board[row][col]) {
                        const piece = document.createElement('span');
                        piece.className = 'piece';
                        piece.textContent = board[row][col];
                        square.appendChild(piece);
                    }
                  
                    chessboard.appendChild(square);
                }
            }
        }
        function handleSquareClick(event) {
            if (gameOver || isAIThinking) return;
            if (gameMode === 'ai' && currentPlayer === 'black') return;
            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);
            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    clearHighlights();
                    switchPlayer();
                    updateDisplay();
                    if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    clearHighlights();
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        selectSquare(row, col);
                    } else {
                        selectedSquare = null;
                    }
                }
            } else {
                if (isPieceOwnedByCurrentPlayer(row, col)) {
                    selectSquare(row, col);
                }
            }
        }
        function selectSquare(row, col) {
            selectedSquare = { row, col };
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            highlightPossibleMoves(row, col);
        }
        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'capture');
            });
        }
        function highlightPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (board[r][c] && !isPieceOwnedByCurrentPlayer(r, c)) {
                            square.classList.add('capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }
        function isPieceOwnedByCurrentPlayer(row, col) {
            const piece = board[row][col];
            if (!piece) return false;
            const whitePieces = Object.values(pieces.white);
            const blackPieces = Object.values(pieces.black);
            return (currentPlayer === 'white' && whitePieces.includes(piece)) ||
                   (currentPlayer === 'black' && blackPieces.includes(piece));
        }
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            if (targetPiece && isPieceOwnedByCurrentPlayer(toRow, toCol)) return false;
            switch (piece) {
                case '♙': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'white');
                case '♟': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'black');
                case '♖': case '♜': return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case '♗': case '♝': return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♕': case '♛': return isValidRookMove(fromRow, fromCol, toRow, toCol) || isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♔': case '♚': return isValidKingMove(fromRow, fromCol, toRow, toCol);
                case '♘': case '♞': return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                default: return false;
            }
        }
        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const targetPiece = board[toRow][toCol];
            if (fromCol === toCol && toRow === fromRow + direction && !targetPiece) return true;
            if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) return true;
            if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && targetPiece) return true;
            return false;
        }
        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }
        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }
        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
        }
        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            return true;
        }
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const move = { fromRow, fromCol, toRow, toCol, piece: board[fromRow][fromCol], captured: board[toRow][toCol] };
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            if ((board[toRow][toCol] === '♟' && toRow === 7) || (board[toRow][toCol] === '♙' && toRow === 0)) {
                board[toRow][toCol] = currentPlayer === 'black' ? '♛' : '♕';
            }
            moveHistory.push(move);
        }
        function undoMove() {
            const move = moveHistory.pop();
            if (!move) return;
            board[move.fromRow][move.fromCol] = move.piece;
            board[move.toRow][move.toCol] = move.captured;
        }
        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
        }
        function updateDisplay() {
            initializeBoard();
            const turnIndicator = document.getElementById('turnIndicator');
            if (isAIThinking) {
                turnIndicator.textContent = "Máy tính đang suy nghĩ...";
                turnIndicator.className = 'turn-indicator thinking';
            } else if (gameMode === 'ai') {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt của bạn" : "Lượt của máy";
                turnIndicator.className = 'turn-indicator';
            } else {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt quân Trắng" : "Lượt quân Đen";
                turnIndicator.className = 'turn-indicator';
            }
            const status = document.getElementById('gameStatus');
            const gameResult = isGameOver();
            const winSound = document.getElementById('winSound');
            const loseSound = document.getElementById('loseSound');
            const tieSound = document.getElementById('tieSound');
            if (gameResult) {
                let message;
                if (gameResult === 'checkmate') {
                    if (gameMode === 'ai') {
                        if (currentPlayer === 'white') {
                            message = 'Chiếu bí! Máy tính thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Máy tính thắng!');
                                winSound.play().catch(e => console.error("Error playing win sound:", e));
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        } else {
                            message = 'Chiếu bí! Bạn thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Bạn thắng!');
                                loseSound.play().catch(e => console.error("Error playing lose sound:", e));
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        }
                    } else {
                        const winner = currentPlayer === 'white' ? 'Đen' : 'Trắng';
                        message = `Chiếu bí! Quân ${winner} thắng!`;
                        if (lastGameResult !== message) {
                            alert(`Chiếu bí! Quân ${winner} thắng!`);
                            if (winner === 'Đen') {
                                winSound.play().catch(e => console.error("Error playing win sound:", e));
                            } else {
                                loseSound.play().catch(e => console.error("Error playing lose sound:", e));
                            }
                            lastGameResult = message;
                        }
                        status.textContent = message;
                    }
                } else if (gameResult === 'stalemate' || gameResult === 'threefold') {
                    message = 'Hòa! Ván cờ kết thúc do bế tắc.';
                    if (lastGameResult !== message) {
                        alert('Hòa! Ván cờ kết thúc do bế tắc.');
                        tieSound.play().catch(e => console.error("Error playing tie sound:", e));
                        lastGameResult = message;
                    }
                    status.textContent = message;
                }
                status.className = 'status check';
                gameOver = true;
            } else if (isCheck()) {
                status.textContent = 'Chiếu!';
                status.className = 'status check';
            } else {
                status.textContent = '';
                status.className = 'status';
            }
        }
        function isCheck() {
            const kingPiece = currentPlayer === 'white' ? '♔' : '♚';
            let kingPos = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        kingPos = { row, col };
                        break;
                    }
                }
            }
            if (!kingPos) return false;
            const opponent = currentPlayer === 'white' ? 'black' : 'white';
            const originalPlayer = currentPlayer;
            currentPlayer = opponent;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, kingPos.row, kingPos.col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }
        function isStalemate() {
            if (isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        function isThreefoldRepetition() {
            if (moveHistory.length < 8) return false;
            const currentBoard = JSON.stringify(board);
            let count = 1;
            for (let i = moveHistory.length - 2; i >= 0; i -= 2) {
                const pastBoard = JSON.stringify(moveHistory[i].boardAfter);
                if (pastBoard === currentBoard) count++;
                if (count >= 3) return true;
            }
            return false;
        }
        function isGameOver() {
            if (isCheck()) {
                if (isCheckmate()) return 'checkmate';
            } else {
                if (isStalemate()) return 'stalemate';
                if (isThreefoldRepetition()) return 'threefold';
            }
            return false;
        }
        function isCheckmate() {
            if (!isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        function resetGame() {
            board = [
                ['♜','♞','♝','♛','♚','♝','♞','♜'],
                ['♟','♟','♟','♟','♟','♟','♟','♟'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['♙','♙','♙','♙','♙','♙','♙','♙'],
                ['♖','♘','♗','♕','♔','♗','♘','♖']
            ];
            currentPlayer = 'black';
            selectedSquare = null;
            gameOver = false;
            isAIThinking = false;
            lastGameResult = null;
            moveHistory = [];
            transpositionTable.clear();
            clearHighlights();
            updateDisplay();
            if (gameMode === 'ai') {
                setTimeout(makeAIMove, 500);
            }
        }
        function changeGameMode() {
            gameMode = document.getElementById('gameMode').value;
            resetGame();
        }
        function makeAIMove() {
            if (gameOver || currentPlayer !== 'black') return;
            isAIThinking = true;
            updateDisplay();
            const bestMove = findBestMove();
            if (bestMove) {
                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                moveHistory[moveHistory.length - 1].boardAfter = JSON.parse(JSON.stringify(board));
                switchPlayer();
            }
            isAIThinking = false;
            updateDisplay();
        }
        function getBoardHash() {
            return JSON.stringify(board) + currentPlayer;
        }
        function findBestMove() {
            let bestMove = null;
            let bestScore = -Infinity;
            const possibleMoves = getAllPossibleMoves('black');
            const orderedMoves = orderMoves(possibleMoves);
            const depth = isEndgame() ? 6 : 5;
            for (const move of orderedMoves) {
                const capturedPiece = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                board[move.fromRow][move.fromCol] = null;
                if ((board[move.toRow][move.toCol] === '♟' && move.toRow === 7)) {
                    board[move.toRow][move.toCol] = '♛';
                }
                const boardHash = getBoardHash();
                let score;
                if (transpositionTable.has(boardHash)) {
                    score = transpositionTable.get(boardHash);
                } else {
                    score = minimax(depth - 1, false, -Infinity, Infinity);
                    transpositionTable.set(boardHash, score);
                }
                board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = capturedPiece;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove || orderedMoves[0];
        }
        function minimax(depth, isMaximizing, alpha, beta) {
            const boardHash = getBoardHash();
            if (transpositionTable.has(boardHash) && depth <= transpositionTable.get(boardHash + '_depth')) {
                return transpositionTable.get(boardHash);
            }
            if (depth === 0 || isGameOver()) {
                const score = evaluateBoard();
                transpositionTable.set(boardHash, score);
                transpositionTable.set(boardHash + '_depth', depth);
                return score;
            }
            const player = isMaximizing ? 'black' : 'white';
            const moves = orderMoves(getAllPossibleMoves(player));
            if (moves.length === 0) {
                const originalPlayer = currentPlayer;
                currentPlayer = player;
                const inCheck = isCheck();
                currentPlayer = originalPlayer;
                const score = inCheck ? (isMaximizing ? -100000 : 100000) : 0;
                transpositionTable.set(boardHash, score);
                transpositionTable.set(boardHash + '_depth', depth);
                return score;
            }
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    if ((board[move.toRow][move.toCol] === '♟' && move.toRow === 7)) {
                        board[move.toRow][move.toCol] = '♛';
                    }
                    const eval = minimax(depth - 1, false, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                transpositionTable.set(boardHash, maxEval);
                transpositionTable.set(boardHash + '_depth', depth);
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    if ((board[move.toRow][move.toCol] === '♙' && move.toRow === 0)) {
                        board[move.toRow][move.toCol] = '♕';
                    }
                    const eval = minimax(depth - 1, true, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                transpositionTable.set(boardHash, minEval);
                transpositionTable.set(boardHash + '_depth', depth);
                return minEval;
            }
        }
        function orderMoves(moves) {
            const scoredMoves = moves.map(move => {
                let score = 0;
                const capturedPiece = board[move.toRow][move.toCol];
                const movingPiece = board[move.fromRow][move.fromCol];
                if (capturedPiece) {
                    score += getPieceValue(capturedPiece) - getPieceValue(movingPiece) * 0.1;
                }
                if (isCheckAfterMove(move)) score += 5000;
                if (isCheckmateAfterMove(move)) score += 100000;
                if (isPromotionMove(move)) score += 9000;
                score += evaluateFork(move) * 500;
                score += evaluatePin(move) * 400;
                score += evaluateDeflection(move) * 600;
                score += evaluateSacrifice(move) * 300;
                score += evaluateCounterAttack(move) * 400;
                score += evaluatePawnStructureDamage(move) * 200;
                score += evaluateOverextensionTrap(move) * 500;
                score += evaluateTransitionToEndgame(move) * 300;
                return { ...move, score };
            });
            return scoredMoves.sort((a, b) => b.score - a.score);
        }
        function isCheckmateAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            if ((board[move.toRow][move.toCol] === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            const originalPlayer = currentPlayer;
            currentPlayer = 'white';
            const isCheckmateResult = isCheckmate();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return isCheckmateResult;
        }
        function evaluateBoard() {
            const pieceValues = {
                '♙': 100, '♟': -100, '♘': 320, '♞': -320, '♗': 330, '♝': -330,
                '♖': 500, '♜': -500, '♕': 900, '♛': -900, '♔': 20000, '♚': -20000
            };
            let score = 0;
            let mobilityScore = 0;
            const originalPlayer = currentPlayer;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        score += pieceValues[piece] || 0;
                        const isWhite = isPieceColor(piece, 'white');
                        const tableRow = isWhite ? row : 7 - row;
                        switch (piece) {
                            case '♙': score += pawnTable[tableRow][col]; break;
                            case '♟': score -= pawnTable[tableRow][col]; break;
                            case '♘': score += knightTable[tableRow][col]; break;
                            case '♞': score -= knightTable[tableRow][col]; break;
                            case '♗': score += bishopTable[tableRow][col]; break;
                            case '♝': score -= bishopTable[tableRow][col]; break;
                            case '♖': score += rookTable[tableRow][col]; break;
                            case '♜': score -= rookTable[tableRow][col]; break;
                            case '♕': score += queenTable[tableRow][col]; break;
                            case '♛': score -= queenTable[tableRow][col]; break;
                            case '♔': score += isEndgame() ? kingTableEnd[tableRow][col] : kingTableMid[tableRow][col]; break;
                            case '♚': score -= isEndgame() ? kingTableEnd[tableRow][col] : kingTableMid[tableRow][col]; break;
                        }
                        if (piece === '♟' || piece === '♙') {
                            const advancement = piece === '♟' ? row : 7 - row;
                            score += (piece === '♟' ? -10 : 10) * advancement;
                            if (isPawnIsolated(row, col, piece)) score += piece === '♟' ? 50 : -50;
                            if (isPawnDoubled(row, col, piece)) score += piece === '♟' ? 30 : -30;
                        }
                    }
                }
            }
            currentPlayer = 'black';
            mobilityScore -= getAllPossibleMoves('black').length * 10;
            currentPlayer = 'white';
            mobilityScore += getAllPossibleMoves('white').length * 10;
            currentPlayer = originalPlayer;
            score += evaluateTacticalPosition();
            score += mobilityScore;
            if (currentPlayer === 'black' && isCheck()) {
                currentPlayer = 'black';
                if (canCheckOpponent()) score += 5000;
                if (canAttackUnprotected()) score += 4000;
                if (isCheckmate()) score += 100000;
                currentPlayer = originalPlayer;
            }
            if (evaluateMaterial() < -1000) {
                score -= 5000;
            }
            return score;
        }
        function evaluateTacticalPosition() {
            let score = 0;
            score += evaluateAllPins() * -50;
            score += evaluateKingSafety();
            if (isEndgame()) {
                score += evaluateEndgameTactics();
            }
            score += evaluateOppositeWingAttack() * 200;
            return score;
        }
        function evaluateFork(move) {
            const piece = board[move.fromRow][move.fromCol];
            const attackedSquares = [];
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            if ((piece === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(move.toRow, move.toCol, row, col)) {
                        const targetPiece = board[row][col];
                        if (targetPiece && isPieceColor(targetPiece, 'white')) {
                            attackedSquares.push({row, col, piece: targetPiece});
                        }
                    }
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return attackedSquares.length >= 2 ? (attackedSquares.some(sq => sq.piece === '♔') ? 2 : 1) : 0;
        }
        function evaluatePin(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (!isLongRangePiece(piece)) return 0;
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            if ((piece === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            let pinScore = 0;
            const directions = getLongRangeDirections(piece);
            for (const [dRow, dCol] of directions) {
                let row = move.toRow + dRow;
                let col = move.toCol + dCol;
                let pinnedPiece = null;
                while (row >= 0 && row < 8 && col >= 0 && col < 8) {
                    const currentPiece = board[row][col];
                    if (currentPiece) {
                        if (!pinnedPiece && isPieceColor(currentPiece, 'white')) {
                            pinnedPiece = {row, col, piece: currentPiece};
                        } else if (pinnedPiece && currentPiece === '♔') {
                            pinScore += getPieceValue(pinnedPiece.piece) / 50;
                            break;
                        } else {
                            break;
                        }
                    }
                    row += dRow;
                    col += dCol;
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return pinScore;
        }
        function evaluateDeflection(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            let score = 0;
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            if ((piece === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            const opponentPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && isPieceColor(board[row][col], 'white')) {
                        opponentPieces.push({ row, col, piece: board[row][col] });
                    }
                }
            }
            for (const target of opponentPieces) {
                if (target.piece === '♕' || target.piece === '♖') {
                    const defenders = findDefenders(target.row, target.col, 'white');
                    for (const defender of defenders) {
                        if (isValidMove(move.toRow, move.toCol, defender.row, defender.col)) {
                            score += getPieceValue(target.piece) / 10;
                        }
                    }
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return score;
        }
        function evaluateSacrifice(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            if (!capturedPiece && (piece === '♟' || piece === '♞' || piece === '♝')) {
                board[move.toRow][move.toCol] = piece;
                board[move.fromRow][move.fromCol] = null;
                if ((piece === '♟' && move.toRow === 7)) {
                    board[move.toRow][move.toCol] = '♛';
                }
                let score = 0;
                if (canCheckOpponent()) score += 5000;
                if (opensCentralFile(move)) score += 2000;
                board[move.fromRow][move.fromCol] = piece;
                board[move.toRow][move.toCol] = capturedPiece;
                return score;
            }
            return 0;
        }
        function evaluateCounterAttack(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            let score = 0;
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            if ((piece === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            const whiteKingPos = findKing('white');
            if (whiteKingPos && (move.toCol <= 2 || move.toCol >= 5)) {
                const distance = Math.abs(move.toCol - whiteKingPos.col);
                score += (7 - distance) * 500;
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return score;
        }
        function evaluatePawnStructureDamage(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            if (capturedPiece === '♙') {
                const col = move.toCol;
                let score = 0;
                if (isPawnIsolated(move.toRow, col, '♙')) score += 1000;
                if (isPawnDoubled(move.toRow, col, '♙')) score += 500;
                return score;
            }
            return 0;
        }
        function evaluateOverextensionTrap(move) {
            const piece = board[move.fromRow][move.fromCol];
            let score = 0;
            if (piece === '♜' || piece === '♛') {
                if (move.toRow >= 5) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = piece;
                    board[move.fromRow][move.fromCol] = null;
                    if ((piece === '♟' && move.toRow === 7)) {
                        board[move.toRow][move.toCol] = '♛';
                    }
                    for (let col = 0; col < 8; col++) {
                        if (board[move.toRow][col] === '♙' && move.toRow >= 4) {
                            score += 2000;
                        }
                    }
                    board[move.fromRow][move.fromCol] = piece;
                    board[move.toRow][move.toCol] = capturedPiece;
                }
            }
            return score;
        }
        function evaluateTransitionToEndgame(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            let score = 0;
            if (capturedPiece === '♕' && piece === '♛') {
                board[move.toRow][move.toCol] = piece;
                board[move.fromRow][move.fromCol] = null;
                if (hasPassedPawn('black')) score += 5000;
                const blackKingPos = findKing('black');
                if (blackKingPos && blackKingPos.row >= 3 && blackKingPos.col >= 3 && blackKingPos.col <= 4) {
                    score += 3000;
                }
                board[move.fromRow][move.fromCol] = piece;
                board[move.toRow][move.toCol] = capturedPiece;
            }
            return score;
        }
        function isPromotionMove(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (piece === '♟' && move.toRow === 7) return true;
            if (piece === '♙' && move.toRow === 0) return true;
            return false;
        }
        function canCheckOpponent() {
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            const whiteKingPos = findKing('white');
            if (!whiteKingPos) return false;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, whiteKingPos.row, whiteKingPos.col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }
        function canAttackUnprotected() {
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPieceColor(piece, 'white') && !isProtected(row, col, 'white')) {
                        for (let fromRow = 0; fromRow < 8; fromRow++) {
                            for (let fromCol = 0; fromCol < 8; fromCol++) {
                                if (isPieceOwnedByCurrentPlayer(fromRow, fromCol) && isValidMove(fromRow, fromCol, row, col)) {
                                    score += getPieceValue(piece) * 2;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return score;
        }
        function isProtected(row, col, color) {
            const originalPlayer = currentPlayer;
            currentPlayer = color;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol) && isValidMove(fromRow, fromCol, row, col)) {
                        currentPlayer = originalPlayer;
                        return true;
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }
        function findDefenders(row, col, color) {
            const defenders = [];
            const originalPlayer = currentPlayer;
            currentPlayer = color;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol) && isValidMove(fromRow, fromCol, row, col)) {
                        defenders.push({ row: fromRow, col: fromCol });
                    }
                }
            }
            currentPlayer = originalPlayer;
            return defenders;
        }
        function canForceDraw() {
            const moves = getAllPossibleMoves('black');
            for (const move of moves) {
                if (isDrawAfterMove(move)) return true;
            }
            return false;
        }
        function isDrawAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            if ((board[move.toRow][move.toCol] === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            const isStalemateResult = isStalemate();
            const isThreefold = isThreefoldRepetition();
            const canPerpetualCheck = canDeliverPerpetualCheck();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return isStalemateResult || isThreefold || canPerpetualCheck;
        }
        function canDeliverPerpetualCheck() {
            const whiteKingPos = findKing('white');
            if (!whiteKingPos) return false;
            let checkCount = 0;
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, whiteKingPos.row, whiteKingPos.col)) {
                            checkCount++;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return checkCount >= 2;
        }
        function evaluateEndgameTactics() {
            let score = 0;
            const blackKingPos = findKing('black');
            const whiteKingPos = findKing('white');
            if (blackKingPos && whiteKingPos) {
                const kingDistance = Math.abs(blackKingPos.row - whiteKingPos.row) + Math.abs(blackKingPos.col - whiteKingPos.col);
                score -= kingDistance * 20;
            }
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === '♟' && row >= 5) {
                        score -= 2000;
                    }
                }
            }
            return score;
        }
        function isEndgame() {
            let pieceCount = 0;
            let queenCount = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col]) {
                        if (['♕', '♛'].includes(board[row][col])) queenCount++;
                        if (!['♔', '♚'].includes(board[row][col])) pieceCount++;
                    }
                }
            }
            return pieceCount <= 10 || queenCount === 0;
        }
        function isCheckAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            if ((board[move.toRow][move.toCol] === '♟' && move.toRow === 7)) {
                board[move.toRow][move.toCol] = '♛';
            }
            const originalPlayer = currentPlayer;
            currentPlayer = 'white';
            const inCheck = isCheck();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return inCheck;
        }
        function evaluateAllPins() {
            let pinScore = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPieceColor(piece, 'black') && isLongRangePiece(piece)) {
                        pinScore += countPinsFromSquare(row, col);
                    }
                }
            }
            return pinScore;
        }
        function evaluateKingSafety() {
            let safetyScore = 0;
            const whiteKingPos = findKing('white');
            if (whiteKingPos) {
                safetyScore += evaluateKingSafetyAt(whiteKingPos.row, whiteKingPos.col, 'white');
            }
            const blackKingPos = findKing('black');
            if (blackKingPos) {
                safetyScore -= evaluateKingSafetyAt(blackKingPos.row, blackKingPos.col, 'black');
            }
            return safetyScore;
        }
        function evaluateOppositeWingAttack() {
            let score = 0;
            const whiteKingPos = findKing('white');
            if (!whiteKingPos) return 0;
            const kingWing = whiteKingPos.col <= 3 ? 'king' : 'queen';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPieceColor(piece, 'black') && (piece === '♜' || piece === '♛')) {
                        if ((kingWing === 'king' && col <= 2) || (kingWing === 'queen' && col >= 5)) {
                            score += 1000;
                        }
                    }
                }
            }
            return score;
        }
        function isPawnIsolated(row, col, piece) {
            const color = piece === '♙' ? 'white' : 'black';
            const adjacentCols = [col - 1, col + 1];
            for (const c of adjacentCols) {
                if (c < 0 || c > 7) continue;
                for (let r = 0; r < 8; r++) {
                    if (board[r][c] && isPieceColor(board[r][c], color) && (board[r][c] === '♙' || board[r][c] === '♟')) {
                        return false;
                    }
                }
            }
            return true;
        }
        function isPawnDoubled(row, col, piece) {
            const color = piece === '♙' ? 'white' : 'black';
            let count = 0;
            for (let r = 0; r < 8; r++) {
                if (board[r][col] && isPieceColor(board[r][col], color) && (board[r][col] === '♙' || board[r][col] === '♟')) {
                    count++;
                }
            }
            return count > 1;
        }
        function hasPassedPawn(color) {
            const pawn = color === 'white' ? '♙' : '♟';
            const direction = color === 'white' ? -1 : 1;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === pawn) {
                        let isPassed = true;
                        for (let r = row + direction; r >= 0 && r < 8; r += direction) {
                            if (board[r][col] || (col > 0 && board[r][col - 1]) || (col < 7 && board[r][col + 1])) {
                                isPassed = false;
                                break;
                            }
                        }
                        if (isPassed) return true;
                    }
                }
            }
            return false;
        }
        function opensCentralFile(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (piece === '♟' && (move.toCol === 3 || move.toCol === 4)) {
                return true;
            }
            return false;
        }
        function evaluateMaterial() {
            const pieceValues = {
                '♙': 100, '♟': -100, '♘': 320, '♞': -320, '♗': 330, '♝': -330,
                '♖': 500, '♜': -500, '♕': 900, '♛': -900, '♔': 20000, '♚': -20000
            };
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) score += pieceValues[piece] || 0;
                }
            }
            return score;
        }
        function isPieceColor(piece, color) {
            const whitePieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
            const blackPieces = ['♚', '♛', '♜', '♝', '♞', '♟'];
            return color === 'white' ? whitePieces.includes(piece) : blackPieces.includes(piece);
        }
        function isLongRangePiece(piece) {
            return ['♕', '♛', '♖', '♜', '♗', '♝'].includes(piece);
        }
        function getLongRangeDirections(piece) {
            const rookDirections = [[0,1], [0,-1], [1,0], [-1,0]];
            const bishopDirections = [[1,1], [1,-1], [-1,1], [-1,-1]];
            if (['♖', '♜'].includes(piece)) return rookDirections;
            if (['♗', '♝'].includes(piece)) return bishopDirections;
            if (['♕', '♛'].includes(piece)) return [...rookDirections, ...bishopDirections];
            return [];
        }
        function getPieceValue(piece) {
            const values = {
                '♙': 100, '♟': 100, '♘': 320, '♞': 320, '♗': 330, '♝': 330,
                '♖': 500, '♜': 500, '♕': 900, '♛': 900, '♔': 20000, '♚': 20000
            };
            return values[piece] || 0;
        }
        function countPinsFromSquare(row, col) {
            const piece = board[row][col];
            const directions = getLongRangeDirections(piece);
            let pinCount = 0;
            for (const [dRow, dCol] of directions) {
                let checkRow = row + dRow;
                let checkCol = col + dCol;
                let pinnedPiece = null;
                while (checkRow >= 0 && checkRow < 8 && checkCol >= 0 && checkCol < 8) {
                    const currentPiece = board[checkRow][checkCol];
                    if (currentPiece) {
                        if (!pinnedPiece && isPieceColor(currentPiece, 'white')) {
                            pinnedPiece = currentPiece;
                        } else if (pinnedPiece && currentPiece === '♔') {
                            pinCount += getPieceValue(pinnedPiece) / 50;
                            break;
                        } else {
                            break;
                        }
                    }
                    checkRow += dRow;
                    checkCol += dCol;
                }
            }
            return pinCount;
        }
        function findKing(color) {
            const kingPiece = color === 'white' ? '♔' : '♚';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        return {row, col};
                    }
                }
            }
            return null;
        }
        function evaluateKingSafetyAt(row, col, color) {
            let safetyScore = 0;
            for (let dRow = -1; dRow <= 1; dRow++) {
                for (let dCol = -1; dCol <= 1; dCol++) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const originalPlayer = currentPlayer;
                        currentPlayer = color === 'white' ? 'black' : 'white';
                        let isAttacked = false;
                        for (let checkRow = 0; checkRow < 8; checkRow++) {
                            for (let checkCol = 0; checkCol < 8; checkCol++) {
                                if (isPieceOwnedByCurrentPlayer(checkRow, checkCol)) {
                                    if (isValidMove(checkRow, checkCol, newRow, newCol)) {
                                        isAttacked = true;
                                        break;
                                    }
                                }
                            }
                            if (isAttacked) break;
                        }
                        currentPlayer = originalPlayer;
                        if (isAttacked) {
                            safetyScore -= 500;
                        } else if (board[newRow][newCol] && isPieceColor(board[newRow][newCol], color)) {
                            safetyScore += 200;
                        }
                    }
                }
            }
            return safetyScore;
        }
        function getAllPossibleMoves(player) {
            const moves = [];
            const originalPlayer = currentPlayer;
            currentPlayer = player;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const capturedPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    if ((board[toRow][toCol] === '♟' && toRow === 7)) {
                                        board[toRow][toCol] = '♛';
                                    }
                                    if ((board[toRow][toCol] === '♙' && toRow === 0)) {
                                        board[toRow][toCol] = '♕';
                                    }
                                    const inCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = capturedPiece;
                                    if (!inCheck) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return moves;
        }
        initializeBoard();
        updateDisplay();
        if (gameMode === 'ai') {
            setTimeout(makeAIMove, 500);
        }
    </script>
</body>
</html>
