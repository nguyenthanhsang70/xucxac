<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - Cờ vua</title>
    <!-- Load Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
       
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
       
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
       
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 20px;
        }
       
        .back-btn {
            position: absolute;
            left: 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        .back-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
        }
       
        h1 {
            text-align: center;
            color: #333;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
       
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(45deg, #f0f2f5, #e1e8ed);
            border-radius: 10px;
        }
       
        .turn-indicator {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }
       
        .game-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
       
        .mode-select {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }
       
        .mode-select:hover {
            transform: translateY(-1px);
        }
       
        .thinking {
            color: #ff9800;
            font-style: italic;
        }
       
        .reset-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.4);
        }
       
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 90, 36, 0.6);
        }
       
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 4px solid #8b4513;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
       
        .square {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
       
        .square.light {
            background: #f0d9b5;
        }
       
        .square.dark {
            background: #b58863;
        }
       
        .square.selected {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 0 3px #ff9800;
        }
       
        .square.possible-move {
            background: rgba(76, 175, 80, 0.6) !important;
        }
       
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #4caf50;
            border-radius: 50%;
            opacity: 0.8;
        }
       
        .square.capture {
            background: rgba(244, 67, 54, 0.6) !important;
        }
       
        .square.capture::after {
            content: '';
            position: absolute;
            border: 3px solid #f44336;
            border-radius: 50%;
            width: 90%;
            height: 90%;
        }
       
        .square:hover {
            filter: brightness(1.1);
        }
       
        .piece {
            user-select: none;
            transition: all 0.2s ease;
        }
       
        .piece:hover {
            transform: scale(1.1);
        }
       
        .status {
            text-align: center;
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            min-height: 25px;
        }
       
        .check {
            color: #f44336;
            animation: pulse 1s infinite;
        }
       
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
       
        .coordinates {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            margin-top: 5px;
        }
       
        .coord {
            width: 70px;
            text-align: center;
            font-size: 0.8rem;
            color: #666;
            font-weight: bold;
        }
       
        @media (max-width: 600px) {
            .square {
                width: 45px;
                height: 45px;
                font-size: 1.8rem;
            }
           
            .coord {
                width: 45px;
            }
           
            h1 {
                font-size: 1.8rem;
            }
           
            .game-container {
                padding: 15px;
            }
           
            .back-btn {
                padding: 6px 10px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <a href="game.html" class="back-btn"><i class="fas fa-arrow-left"></i></a>
            <h1>♔ Chess - Cờ vua ♛</h1>
        </div>
       
        <div class="game-info">
            <div class="turn-indicator" id="turnIndicator">White's Turn</div>
            <div class="game-controls">
                <select id="gameMode" onchange="changeGameMode()" class="mode-select">
                    <option value="human">2 Người chơi</option>
                    <option value="ai">Chơi với máy</option>
                </select>
                <button class="reset-btn" onclick="resetGame()">Ván mới</button>
            </div>
        </div>
       
        <div class="chessboard" id="chessboard"></div>
       
        <div class="coordinates">
            <div class="coord">a</div>
            <div class="coord">b</div>
            <div class="coord">c</div>
            <div class="coord">d</div>
            <div class="coord">e</div>
            <div class="coord">f</div>
            <div class="coord">g</div>
            <div class="coord">h</div>
        </div>
       
        <div class="status" id="gameStatus"></div>
    </div>
    <script>
        const pieces = {
            white: {
                king: '♔', queen: '♕', rook: '♖',
                bishop: '♗', knight: '♘', pawn: '♙'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜',
                bishop: '♝', knight: '♞', pawn: '♟'
            }
        };

        let board = [
            ['♜','♞','♝','♛','♚','♝','♞','♜'],
            ['♟','♟','♟','♟','♟','♟','♟','♟'],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            ['♙','♙','♙','♙','♙','♙','♙','♙'],
            ['♖','♘','♗','♕','♔','♗','♘','♖']
        ];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameOver = false;
        let gameMode = 'human';
        let isAIThinking = false;
        let lastGameResult = null;
        let moveHistory = [];

        function initializeBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', handleSquareClick);
                   
                    if (board[row][col]) {
                        const piece = document.createElement('span');
                        piece.className = 'piece';
                        piece.textContent = board[row][col];
                        square.appendChild(piece);
                    }
                   
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(event) {
            if (gameOver || isAIThinking) return;
            if (gameMode === 'ai' && currentPlayer === 'black') return;
            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);
            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    clearHighlights();
                    switchPlayer();
                    updateDisplay();
                    if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    clearHighlights();
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        selectSquare(row, col);
                    } else {
                        selectedSquare = null;
                    }
                }
            } else {
                if (isPieceOwnedByCurrentPlayer(row, col)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            selectedSquare = { row, col };
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            highlightPossibleMoves(row, col);
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'capture');
            });
        }

        function highlightPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (board[r][c] && !isPieceOwnedByCurrentPlayer(r, c)) {
                            square.classList.add('capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }

        function isPieceOwnedByCurrentPlayer(row, col) {
            const piece = board[row][col];
            if (!piece) return false;
            const whitePieces = Object.values(pieces.white);
            const blackPieces = Object.values(pieces.black);
            return (currentPlayer === 'white' && whitePieces.includes(piece)) ||
                   (currentPlayer === 'black' && blackPieces.includes(piece));
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            if (targetPiece && isPieceOwnedByCurrentPlayer(toRow, toCol)) return false;
            switch (piece) {
                case '♙': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'white');
                case '♟': return isValidPawnMove(fromRow, fromCol, toRow, toCol, 'black');
                case '♖': case '♜': return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case '♗': case '♝': return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♕': case '♛': return isValidRookMove(fromRow, fromCol, toRow, toCol) || isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case '♔': case '♚': return isValidKingMove(fromRow, fromCol, toRow, toCol);
                case '♘': case '♞': return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                default: return false;
            }
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const targetPiece = board[toRow][toCol];
            if (fromCol === toCol && toRow === fromRow + direction && !targetPiece) return true;
            if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) return true;
            if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && targetPiece) return true;
            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const move = { fromRow, fromCol, toRow, toCol, piece: board[fromRow][fromCol], captured: board[toRow][toCol] };
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            moveHistory.push(move);
        }

        function undoMove() {
            const move = moveHistory.pop();
            if (!move) return;
            board[move.fromRow][move.fromCol] = move.piece;
            board[move.toRow][move.toCol] = move.captured;
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
        }

        function updateDisplay() {
            initializeBoard();
            const turnIndicator = document.getElementById('turnIndicator');
            if (isAIThinking) {
                turnIndicator.textContent = "Máy tính đang suy nghĩ...";
                turnIndicator.className = 'turn-indicator thinking';
            } else if (gameMode === 'ai') {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt của bạn" : "Lượt của máy";
                turnIndicator.className = 'turn-indicator';
            } else {
                turnIndicator.textContent = currentPlayer === 'white' ? "Lượt quân Trắng" : "Lượt quân Đen";
                turnIndicator.className = 'turn-indicator';
            }
            const status = document.getElementById('gameStatus');
            const gameResult = isGameOver();
            if (gameResult) {
                let message;
                if (gameResult === 'checkmate') {
                    if (gameMode === 'ai') {
                        if (currentPlayer === 'white') {
                            message = 'Chiếu bí! Máy tính thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Máy tính thắng!');
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        } else {
                            message = 'Chiếu bí! Bạn thắng!';
                            if (lastGameResult !== message) {
                                alert('Chiếu bí! Bạn thắng!');
                                lastGameResult = message;
                            }
                            status.textContent = message;
                        }
                    } else {
                        const winner = currentPlayer === 'white' ? 'Đen' : 'Trắng';
                        message = `Chiếu bí! Quân ${winner} thắng!`;
                        if (lastGameResult !== message) {
                            alert(`Chiếu bí! Quân ${winner} thắng!`);
                            lastGameResult = message;
                        }
                        status.textContent = message;
                    }
                } else if (gameResult === 'stalemate' || gameResult === 'threefold') {
                    message = 'Hòa! Ván cờ kết thúc do bế tắc.';
                    if (lastGameResult !== message) {
                        alert('Hòa! Ván cờ kết thúc do bế tắc.');
                        lastGameResult = message;
                    }
                    status.textContent = message;
                }
                status.className = 'status check';
                gameOver = true;
            } else if (isCheck()) {
                status.textContent = 'Chiếu!';
                status.className = 'status check';
            } else {
                status.textContent = '';
                status.className = 'status';
            }
        }

        function isCheck() {
            const kingPiece = currentPlayer === 'white' ? '♔' : '♚';
            let kingPos = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        kingPos = { row, col };
                        break;
                    }
                }
            }
            if (!kingPos) return false;
            const opponent = currentPlayer === 'white' ? 'black' : 'white';
            const originalPlayer = currentPlayer;
            currentPlayer = opponent;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, kingPos.row, kingPos.col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }

        function isStalemate() {
            if (isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        function isThreefoldRepetition() {
            if (moveHistory.length < 8) return false;
            const currentBoard = JSON.stringify(board);
            let count = 1;
            for (let i = moveHistory.length - 2; i >= 0; i -= 2) {
                const pastBoard = JSON.stringify(moveHistory[i].boardAfter);
                if (pastBoard === currentBoard) count++;
                if (count >= 3) return true;
            }
            return false;
        }

        function isGameOver() {
            if (isCheck()) {
                if (isCheckmate()) return 'checkmate';
            } else {
                if (isStalemate()) return 'stalemate';
                if (isThreefoldRepetition()) return 'threefold';
            }
            return false;
        }

        function isCheckmate() {
            if (!isCheck()) return false;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const originalPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const stillInCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = originalPiece;
                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        function resetGame() {
            board = [
                ['♜','♞','♝','♛','♚','♝','♞','♜'],
                ['♟','♟','♟','♟','♟','♟','♟','♟'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['♙','♙','♙','♙','♙','♙','♙','♙'],
                ['♖','♘','♗','♕','♔','♗','♘','♖']
            ];
            currentPlayer = 'white';
            selectedSquare = null;
            gameOver = false;
            isAIThinking = false;
            lastGameResult = null;
            moveHistory = [];
            clearHighlights();
            updateDisplay();
        }

        function changeGameMode() {
            gameMode = document.getElementById('gameMode').value;
            resetGame();
        }

        function makeAIMove() {
            if (gameOver || currentPlayer !== 'black') return;
            isAIThinking = true;
            updateDisplay();
            const bestMove = findBestMove();
            if (bestMove) {
                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                moveHistory[moveHistory.length - 1].boardAfter = JSON.parse(JSON.stringify(board));
                switchPlayer();
            }
            isAIThinking = false;
            updateDisplay();
        }

        function findBestMove() {
            let bestMove = null;
            let bestScore = -Infinity;
            const possibleMoves = getAllPossibleMoves('black');
            const orderedMoves = orderMoves(possibleMoves);
            const depth = isEndgame() ? 4 : 3;

            for (const move of orderedMoves) {
                const capturedPiece = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                board[move.fromRow][move.fromCol] = null;
                const score = minimax(depth, false, -Infinity, Infinity);
                board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                board[move.toRow][move.toCol] = capturedPiece;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove || orderedMoves[0];
        }

        function minimax(depth, isMaximizing, alpha, beta) {
            if (depth === 0 || isGameOver()) {
                return evaluateBoard();
            }
            const player = isMaximizing ? 'black' : 'white';
            const moves = orderMoves(getAllPossibleMoves(player));
            if (moves.length === 0) {
                const originalPlayer = currentPlayer;
                currentPlayer = player;
                const inCheck = isCheck();
                currentPlayer = originalPlayer;
                return inCheck ? (isMaximizing ? -10000 : 10000) : 0;
            }
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    const eval = minimax(depth - 1, false, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = null;
                    const eval = minimax(depth - 1, true, alpha, beta);
                    board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = capturedPiece;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function orderMoves(moves) {
            const scoredMoves = moves.map(move => {
                let score = 0;
                const capturedPiece = board[move.toRow][move.toCol];
                if (capturedPiece) {
                    score += getPieceValue(capturedPiece);
                    // Forced Exchange: Prioritize capturing opponent's queen or rook
                    if (capturedPiece === '♕' || capturedPiece === '♖') score += 50;
                }
                if (isCheckAfterMove(move)) score += 100;
                score += evaluateFork(move) * 50;
                score += evaluatePin(move) * 40;
                score += evaluateDeflection(move) * 60; // New: Deflection tactic
                score += evaluateSacrifice(move) * 30; // New: Provocative Sacrifice
                score += evaluateCounterAttack(move) * 40; // New: Counter-Attack
                score += evaluatePawnStructureDamage(move) * 20; // New: Destroy Pawn Structure
                score += evaluateOverextensionTrap(move) * 50; // New: Overextension Trap
                score += evaluateTransitionToEndgame(move) * 30; // New: Transition Trick
                if (isDrawAfterMove(move)) score += evaluateBoard() < -100 ? 500 : 0; // New: Draw Trap
                return { ...move, score };
            });
            return scoredMoves.sort((a, b) => b.score - a.score);
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            const originalPlayer = currentPlayer;
            currentPlayer = player;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    const capturedPiece = board[toRow][toCol];
                                    board[toRow][toCol] = board[fromRow][fromCol];
                                    board[fromRow][fromCol] = null;
                                    const inCheck = isCheck();
                                    board[fromRow][fromCol] = board[toRow][toCol];
                                    board[toRow][toCol] = capturedPiece;
                                    if (!inCheck) {
                                        moves.push({ fromRow, fromCol, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return moves;
        }

        function evaluateBoard() {
            const pieceValues = {
                '♙': 10, '♟': -10, '♘': 30, '♞': -30, '♗': 30, '♝': -30,
                '♖': 50, '♜': -50, '♕': 90, '♛': -90, '♔': 900, '♚': -900
            };
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        score += pieceValues[piece] || 0;
                        if (piece === '♟' || piece === '♙') {
                            const advancement = piece === '♟' ? row : 7 - row;
                            score += (piece === '♟' ? -1 : 1) * advancement * 0.5;
                            // Penalize opponent's isolated or doubled pawns
                            if (isPawnIsolated(row, col, piece)) score += piece === '♟' ? 5 : -5;
                            if (isPawnDoubled(row, col, piece)) score += piece === '♟' ? 3 : -3;
                        }
                        if (row >= 3 && row <= 4 && col >= 3 && col <= 4) {
                            score += (piece === '♟' || piece === '♞' || piece === '♝' || piece === '♜' || piece === '♛') ? -1 : 1;
                        }
                    }
                }
            }
            score += evaluateTacticalPosition();
            // Active Defense: Boost score if AI can check or threaten pieces when in check
            if (currentPlayer === 'black' && isCheck()) {
                const originalPlayer = currentPlayer;
                currentPlayer = 'black';
                if (canCheckOpponent()) score += 50;
                if (canAttackUnprotected()) score += 40;
                currentPlayer = originalPlayer;
            }
            // Draw Trap: Prioritize draw if losing badly
            if (evaluateMaterial() < -100) {
                if (canForceDraw()) score += 500;
            }
            return score;
        }

        function evaluateTacticalPosition() {
            let score = 0;
            score += evaluateAllPins() * -5;
            score += evaluateKingSafety();
            if (isEndgame()) {
                score += evaluateEndgameTactics();
            }
            // Counter-Attack: Evaluate attacking opponent's weak wing
            score += evaluateOppositeWingAttack() * 20;
            return score;
        }

        function evaluateFork(move) {
            const piece = board[move.fromRow][move.fromCol];
            const attackedSquares = [];
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(move.toRow, move.toCol, row, col)) {
                        const targetPiece = board[row][col];
                        if (targetPiece && isPieceColor(targetPiece, 'white')) {
                            attackedSquares.push({row, col, piece: targetPiece});
                        }
                    }
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return attackedSquares.length >= 2 ? (attackedSquares.some(sq => sq.piece === '♔') ? 2 : 1) : 0;
        }

        function evaluatePin(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (!isLongRangePiece(piece)) return 0;
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            let pinScore = 0;
            const directions = getLongRangeDirections(piece);
            for (const [dRow, dCol] of directions) {
                let row = move.toRow + dRow;
                let col = move.toCol + dCol;
                let pinnedPiece = null;
                while (row >= 0 && row < 8 && col >= 0 && col < 8) {
                    const currentPiece = board[row][col];
                    if (currentPiece) {
                        if (!pinnedPiece && isPieceColor(currentPiece, 'white')) {
                            pinnedPiece = {row, col, piece: currentPiece};
                        } else if (pinnedPiece && currentPiece === '♔') {
                            pinScore += 1;
                            break;
                        } else {
                            break;
                        }
                    }
                    row += dRow;
                    col += dCol;
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return pinScore;
        }

        function evaluateDeflection(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            let score = 0;
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            const opponentPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && isPieceColor(board[row][col], 'white')) {
                        opponentPieces.push({ row, col, piece: board[row][col] });
                    }
                }
            }
            for (const target of opponentPieces) {
                if (target.piece === '♕' || target.piece === '♖') {
                    const defenders = findDefenders(target.row, target.col, 'white');
                    for (const defender of defenders) {
                        if (isValidMove(move.toRow, move.toCol, defender.row, defender.col)) {
                            score += getPieceValue(target.piece) / 2;
                        }
                    }
                }
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return score;
        }

        function evaluateSacrifice(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            if (!capturedPiece && (piece === '♟' || piece === '♞' || piece === '♝')) {
                board[move.toRow][move.toCol] = piece;
                board[move.fromRow][move.fromCol] = null;
                let score = 0;
                if (canCheckOpponent()) score += 50;
                if (opensCentralFile(move)) score += 20;
                board[move.fromRow][move.fromCol] = piece;
                board[move.toRow][move.toCol] = capturedPiece;
                return score;
            }
            return 0;
        }

        function evaluateCounterAttack(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            let score = 0;
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = null;
            const whiteKingPos = findKing('white');
            if (whiteKingPos && (move.toCol <= 2 || move.toCol >= 5)) {
                const distance = Math.abs(move.toCol - whiteKingPos.col);
                score += (7 - distance) * 5;
            }
            board[move.fromRow][move.fromCol] = piece;
            board[move.toRow][move.toCol] = capturedPiece;
            return score;
        }

        function evaluatePawnStructureDamage(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            if (capturedPiece === '♙') {
                const col = move.toCol;
                let score = 0;
                if (isPawnIsolated(move.toRow, col, '♙')) score += 10;
                if (isPawnDoubled(move.toRow, col, '♙')) score += 5;
                return score;
            }
            return 0;
        }

        function evaluateOverextensionTrap(move) {
            const piece = board[move.fromRow][move.fromCol];
            let score = 0;
            if (piece === '♜' || piece === '♛') {
                if (move.toRow >= 5) { // AI's rook/queen on opponent's 7th/8th rank
                    const capturedPiece = board[move.toRow][move.toCol];
                    board[move.toRow][move.toCol] = piece;
                    board[move.fromRow][move.fromCol] = null;
                    for (let col = 0; col < 8; col++) {
                        if (board[move.toRow][col] === '♙' && move.toRow >= 4) {
                            score += 20;
                        }
                    }
                    board[move.fromRow][move.fromCol] = piece;
                    board[move.toRow][move.toCol] = capturedPiece;
                }
            }
            return score;
        }

        function evaluateTransitionToEndgame(move) {
            const piece = board[move.fromRow][move.fromCol];
            const capturedPiece = board[move.toRow][move.toCol];
            let score = 0;
            if (capturedPiece === '♕' && piece === '♛') {
                board[move.toRow][move.toCol] = piece;
                board[move.fromRow][move.fromCol] = null;
                if (hasPassedPawn('black')) score += 50;
                const blackKingPos = findKing('black');
                if (blackKingPos && blackKingPos.row >= 3 && blackKingPos.col >= 3 && blackKingPos.col <= 4) {
                    score += 30;
                }
                board[move.fromRow][move.fromCol] = piece;
                board[move.toRow][move.toCol] = capturedPiece;
            }
            return score;
        }

        function canCheckOpponent() {
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            const whiteKingPos = findKing('white');
            if (!whiteKingPos) return false;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, whiteKingPos.row, whiteKingPos.col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }

        function canAttackUnprotected() {
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPieceColor(piece, 'white') && !isProtected(row, col, 'white')) {
                        for (let fromRow = 0; fromRow < 8; fromRow++) {
                            for (let fromCol = 0; fromCol < 8; fromCol++) {
                                if (isPieceOwnedByCurrentPlayer(fromRow, fromCol) && isValidMove(fromRow, fromCol, row, col)) {
                                    score += getPieceValue(piece);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return score;
        }

        function isProtected(row, col, color) {
            const originalPlayer = currentPlayer;
            currentPlayer = color;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol) && isValidMove(fromRow, fromCol, row, col)) {
                        currentPlayer = originalPlayer;
                        return true;
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }

        function findDefenders(row, col, color) {
            const defenders = [];
            const originalPlayer = currentPlayer;
            currentPlayer = color;
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    if (isPieceOwnedByCurrentPlayer(fromRow, fromCol) && isValidMove(fromRow, fromCol, row, col)) {
                        defenders.push({ row: fromRow, col: fromCol });
                    }
                }
            }
            currentPlayer = originalPlayer;
            return defenders;
        }

        function canForceDraw() {
            const moves = getAllPossibleMoves('black');
            for (const move of moves) {
                if (isDrawAfterMove(move)) return true;
            }
            return false;
        }

        function isDrawAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            const isStalemateResult = isStalemate();
            const isThreefold = isThreefoldRepetition();
            const canPerpetualCheck = canDeliverPerpetualCheck();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return isStalemateResult || isThreefold || canPerpetualCheck;
        }

        function canDeliverPerpetualCheck() {
            const whiteKingPos = findKing('white');
            if (!whiteKingPos) return false;
            let checkCount = 0;
            const originalPlayer = currentPlayer;
            currentPlayer = 'black';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPieceOwnedByCurrentPlayer(row, col)) {
                        if (isValidMove(row, col, whiteKingPos.row, whiteKingPos.col)) {
                            checkCount++;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return checkCount >= 2; // Simplified: Assumes multiple checks indicate potential for perpetual
        }

        function evaluateEndgameTactics() {
            let score = 0;
            const blackKingPos = findKing('black');
            const whiteKingPos = findKing('white');
            if (blackKingPos && whiteKingPos) {
                const kingDistance = Math.abs(blackKingPos.row - whiteKingPos.row) + Math.abs(blackKingPos.col - whiteKingPos.col);
                score -= kingDistance * 2;
            }
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === '♟' && row <= 2) {
                        score -= 20;
                    }
                }
            }
            return score;
        }

        function isEndgame() {
            let pieceCount = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && !['♔', '♚'].includes(board[row][col])) {
                        pieceCount++;
                    }
                }
            }
            return pieceCount <= 12;
        }

        function isCheckAfterMove(move) {
            const capturedPiece = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
            board[move.fromRow][move.fromCol] = null;
            const originalPlayer = currentPlayer;
            currentPlayer = 'white';
            const inCheck = isCheck();
            currentPlayer = originalPlayer;
            board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
            board[move.toRow][move.toCol] = capturedPiece;
            return inCheck;
        }

        function evaluateAllPins() {
            let pinScore = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPieceColor(piece, 'black') && isLongRangePiece(piece)) {
                        pinScore += countPinsFromSquare(row, col);
                    }
                }
            }
            return pinScore;
        }

        function evaluateKingSafety() {
            let safetyScore = 0;
            const whiteKingPos = findKing('white');
            if (whiteKingPos) {
                safetyScore += evaluateKingSafetyAt(whiteKingPos.row, whiteKingPos.col, 'white');
            }
            const blackKingPos = findKing('black');
            if (blackKingPos) {
                safetyScore -= evaluateKingSafetyAt(blackKingPos.row, blackKingPos.col, 'black');
            }
            return safetyScore;
        }

        function evaluateOppositeWingAttack() {
            let score = 0;
            const whiteKingPos = findKing('white');
            if (!whiteKingPos) return 0;
            const kingWing = whiteKingPos.col <= 3 ? 'king' : 'queen';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPieceColor(piece, 'black') && (piece === '♜' || piece === '♛')) {
                        if ((kingWing === 'king' && col <= 2) || (kingWing === 'queen' && col >= 5)) {
                            score += 10;
                        }
                    }
                }
            }
            return score;
        }

        function isPawnIsolated(row, col, piece) {
            const color = piece === '♙' ? 'white' : 'black';
            const adjacentCols = [col - 1, col + 1];
            for (const c of adjacentCols) {
                if (c < 0 || c > 7) continue;
                for (let r = 0; r < 8; r++) {
                    if (board[r][c] && isPieceColor(board[r][c], color) && (board[r][c] === '♙' || board[r][c] === '♟')) {
                        return false;
                    }
                }
            }
            return true;
        }

        function isPawnDoubled(row, col, piece) {
            const color = piece === '♙' ? 'white' : 'black';
            let count = 0;
            for (let r = 0; r < 8; r++) {
                if (board[r][col] && isPieceColor(board[r][col], color) && (board[r][col] === '♙' || board[r][col] === '♟')) {
                    count++;
                }
            }
            return count > 1;
        }

        function hasPassedPawn(color) {
            const pawn = color === 'white' ? '♙' : '♟';
            const direction = color === 'white' ? -1 : 1;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === pawn) {
                        let isPassed = true;
                        for (let r = row + direction; r >= 0 && r < 8; r += direction) {
                            if (board[r][col] || (col > 0 && board[r][col - 1]) || (col < 7 && board[r][col + 1])) {
                                isPassed = false;
                                break;
                            }
                        }
                        if (isPassed) return true;
                    }
                }
            }
            return false;
        }

        function opensCentralFile(move) {
            const piece = board[move.fromRow][move.fromCol];
            if (piece === '♟' && (move.toCol === 3 || move.toCol === 4)) {
                return true;
            }
            return false;
        }

        function evaluateMaterial() {
            const pieceValues = {
                '♙': 10, '♟': -10, '♘': 30, '♞': -30, '♗': 30, '♝': -30,
                '♖': 50, '♜': -50, '♕': 90, '♛': -90, '♔': 900, '♚': -900
            };
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) score += pieceValues[piece] || 0;
                }
            }
            return score;
        }

        function isPieceColor(piece, color) {
            const whitePieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
            const blackPieces = ['♚', '♛', '♜', '♝', '♞', '♟'];
            return color === 'white' ? whitePieces.includes(piece) : blackPieces.includes(piece);
        }

        function isLongRangePiece(piece) {
            return ['♕', '♛', '♖', '♜', '♗', '♝'].includes(piece);
        }

        function getLongRangeDirections(piece) {
            const rookDirections = [[0,1], [0,-1], [1,0], [-1,0]];
            const bishopDirections = [[1,1], [1,-1], [-1,1], [-1,-1]];
            if (['♖', '♜'].includes(piece)) return rookDirections;
            if (['♗', '♝'].includes(piece)) return bishopDirections;
            if (['♕', '♛'].includes(piece)) return [...rookDirections, ...bishopDirections];
            return [];
        }

        function getPieceValue(piece) {
            const values = {
                '♙': 10, '♟': 10, '♘': 30, '♞': 30, '♗': 30, '♝': 30,
                '♖': 50, '♜': 50, '♕': 90, '♛': 90, '♔': 900, '♚': 900
            };
            return values[piece] || 0;
        }

        function countPinsFromSquare(row, col) {
            const piece = board[row][col];
            const directions = getLongRangeDirections(piece);
            let pinCount = 0;
            for (const [dRow, dCol] of directions) {
                let checkRow = row + dRow;
                let checkCol = col + dCol;
                let pinnedPiece = null;
                while (checkRow >= 0 && checkRow < 8 && checkCol >= 0 && checkCol < 8) {
                    const currentPiece = board[checkRow][checkCol];
                    if (currentPiece) {
                        if (!pinnedPiece && isPieceColor(currentPiece, 'white')) {
                            pinnedPiece = currentPiece;
                        } else if (pinnedPiece && currentPiece === '♔') {
                            pinCount++;
                            break;
                        } else {
                            break;
                        }
                    }
                    checkRow += dRow;
                    checkCol += dCol;
                }
            }
            return pinCount;
        }

        function findKing(color) {
            const kingPiece = color === 'white' ? '♔' : '♚';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        return {row, col};
                    }
                }
            }
            return null;
        }

        function evaluateKingSafetyAt(row, col, color) {
            let safetyScore = 0;
            for (let dRow = -1; dRow <= 1; dRow++) {
                for (let dCol = -1; dCol <= 1; dCol++) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const originalPlayer = currentPlayer;
                        currentPlayer = color === 'white' ? 'black' : 'white';
                        let isAttacked = false;
                        for (let checkRow = 0; checkRow < 8; checkRow++) {
                            for (let checkCol = 0; checkCol < 8; checkCol++) {
                                if (isPieceOwnedByCurrentPlayer(checkRow, checkCol)) {
                                    if (isValidMove(checkRow, checkCol, newRow, newCol)) {
                                        isAttacked = true;
                                        break;
                                    }
                                }
                            }
                            if (isAttacked) break;
                        }
                        currentPlayer = originalPlayer;
                        if (isAttacked) {
                            safetyScore -= 5;
                        }
                    }
                }
            }
            return safetyScore;
        }

        initializeBoard();
        updateDisplay();
    </script>
</body>
</html>
